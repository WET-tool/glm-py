{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GLM-py","text":"<p>A Python package to make running General Lake Model (GLM) simulations easier across many environments: cloud, web application, HPC, or your machine.</p>"},{"location":"#glm","title":"GLM","text":"<p>GLM is a 1-dimensional lake water balance and stratification model. It is coupled with a powerful ecological modelling library to also support simulations of lake water quality and ecosystems processes.</p> <p>GLM is suitable for a wide range of natural and engineered lakes, including shallow (well-mixed) and deep (stratified) systems. The model has been successfully applied to systems from the scale of individual ponds and wetlands to the scale of Great Lakes.</p> <p>For more information about running GLM please see the model website's scientific basis description and the GLM workbook. </p> <p>The GLM model is available as an executable for Linux (Ubuntu), MacOS, and Windows. It is actively developed by the  Aquatic EcoDynamics research group at The University of Western Australia.</p>"},{"location":"#why-glm-py","title":"Why GLM-py?","text":"<p>GLM-py provides a series of classes, functions, and data structures that to support running GLM simulations, preparing model input data and configurations, and processing model outputs. </p> <p>Its goal is to make running and deploying GLM in a range of environments easy such as building web APIs around GLM within web applications or cloud services, running batches of GLM simulations on HPCs, or running GLM simulations locally within Python environments such as JupyterLab or QGIS. </p>"},{"location":"#nml","title":"NML","text":"<p>Classes to store properties describing GLM simulation input data and configuration and methods to generate <code>.nml</code> config files required for running GLM. </p>"},{"location":"#dimensions","title":"Dimensions","text":"<p>Take simple user descriptions of lake geometry or dimensions and generate detailed representations of lake morphometry required for GLM simulations.</p>"},{"location":"#json","title":"JSON","text":"<p>Convert JSON data to <code>.nml</code> format data. Useful for handling client requests if GLM is deployed within a web API / REST API.</p>"},{"location":"#simulations","title":"Simulations","text":"<p>Run GLM simulations and process output data into CSV, JSON, or NetCDF files or generate a JSON stream to pass onto clients. </p>"},{"location":"development/","title":"Development setup","text":""},{"location":"development/#environment","title":"Environment","text":"<p>A Docker container can be used to create a development environment. You can either build the Docker image:</p> <p><pre><code>docker build -t glmpy-dev .devcontainer\n</code></pre> Or, you can develop glmpy using a dev container. </p>"},{"location":"development/#code-style","title":"Code style","text":"<p>Code linting and formatting uses ruff and black. A script to format the glm-met repository can be run: <code>./scripts/format.sh</code>. </p> <p>pre-commit is used to run ruff and black. </p>"},{"location":"development/#tests","title":"Tests","text":"<p>pytest is used for testing glm-met. </p> <p>If testing, please add tests under the <code>tests</code> directory. If you need test data for running tests, add them as <code>pytest.fixtures</code> in <code>conftest.py</code>. </p> <p>Build the docs (from the package root): </p> <pre><code>mkdocs serve \n</code></pre>"},{"location":"development/#code-style_1","title":"Code style","text":"<ul> <li>Format all code using black (see <code>./scripts/format.sh</code>)</li> <li>Manually correct all ruff errors</li> <li>Use pre-commit to format Python code before git commits</li> <li>Use NumPy style docstrings - follow NumPy conventions</li> </ul>"},{"location":"development/#methods-function-docstring","title":"Methods / function docstring","text":"<p>Example from Pandas:</p> <ul> <li>Summary - one line function / method summary.</li> <li>Extended summary - one or two sentences outlining what the function achieves and when / where it is used.</li> <li>Parameter description - list function arguments, keywords, and types.</li> <li>Returns / yields section - list returns / yields from the function and their types.</li> <li>Notes - optional notes section.</li> <li>Examples - example to illustrate how the function can be used.</li> </ul> <pre><code>\"\"\"\nAdd up two integer numbers.\n\nThis function simply wraps the ``+`` operator, and does not\ndo anything interesting, except for illustrating what\nthe docstring of a very simple function looks like.\n\nParameters\n----------\nnum1 : int\n    First number to add.\nnum2 : int\n    Second number to add.\n\nReturns\n-------\nint\n    The sum of ``num1`` and ``num2``.\n\nSee Also\n--------\nsubtract : Subtract one integer from another.\n\nExamples\n--------\n&gt;&gt;&gt; add(2, 2)\n4\n&gt;&gt;&gt; add(25, 0)\n25\n&gt;&gt;&gt; add(10, -10)\n0\n\"\"\"\n</code></pre>"},{"location":"development/#class-docstring","title":"Class docstring","text":"<ul> <li>Summary - one line class summary.</li> <li>Extended summary - one or two sentences outlining the class purpose and use.</li> <li>Attributes description - list function arguments, keywords, and types.</li> <li>Example - short example indicating class usage.</li> <li>Notes - optional notes section</li> </ul> <p>Do not list methods - add docstrings to methods within the class. </p>"},{"location":"development/#build-package","title":"Build package","text":"<pre><code>python -m build\n</code></pre>"},{"location":"dimensions/","title":"Dimensions","text":""},{"location":"dimensions/#glmpy.dimensions.SimpleCircularWaterBody","title":"<code>SimpleCircularWaterBody</code>","text":"<p>Calculates the volume and surface area of a circular water body.</p> <p>Assumes only the height, radius, and surface radius are known. Enables calculation of the volume and surface area of the water body at each height increment.</p> <p>Attributes:</p> Name Type Description <code>height</code> <code>float</code> <p>height of dam, metres</p> <code>surface_radius</code> <code>float</code> <p>surface radius of dam, metres</p> <code>side_slope</code> <code>float</code> <p>side slope of dam, by default 3</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; my_dam = SimpleCircularWaterBody(3, 5)\n&gt;&gt;&gt; my_dam.get_volumes()\n[0.0, 11.148148148148149, 27.185185185185183, 49.0]\n&gt;&gt;&gt; my_dam.get_surface_areas()\n[9.0, 13.444444444444443, 18.777777777777775, 25.0]\n</code></pre>"},{"location":"dimensions/#glmpy.dimensions.SimpleCircularWaterBody.get_volumes","title":"<code>get_volumes()</code>","text":"<p>Calculates volumes.</p> <p>Returns the volume of the water body at each height increment.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Name Type Description <code>volume</code> <code>list</code> <p>The volume of water body (m^3) at each metre height increment.</p>"},{"location":"dimensions/#glmpy.dimensions.SimpleTruncatedPyramidWaterBody","title":"<code>SimpleTruncatedPyramidWaterBody</code>","text":"<p>Calculates the volume and surface area of a truncated pyramid water body.</p> <p>Assumes only the height, slope, and surface dimensions of a truncated pyramid water body are known. Enables calculation of the volume and surface area of the water body at each height increment.</p> <p>Attributes:</p> Name Type Description <code>height</code> <code>float</code> <p>Height of dam, metres.</p> <code>surface_width</code> <code>float</code> <p>Width of dam, metres.</p> <code>surface_length</code> <code>float</code> <p>Length of dam, metres.</p> <code>side_slope</code> <code>float</code> <p>Side slope of dam - the rise over run, metres/metre. By default, 3.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; my_dam = SimpleTruncatedPyramidWaterBody(3, 5, 5)\n&gt;&gt;&gt; my_dam.get_volumes()\n[0.0, 11.148148148148149, 27.185185185185183, 49.0]\n&gt;&gt;&gt; my_dam.get_surface_areas()\n[9.0, 13.444444444444443, 18.777777777777775, 25.0]\n</code></pre>"},{"location":"dimensions/#glmpy.dimensions.SimpleTruncatedPyramidWaterBody.get_heights","title":"<code>get_heights()</code>","text":"<p>Calculates heights.</p> <p>Returns a list of heights from base to surface.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Name Type Description <code>heights</code> <code>list</code> <p>Heights (m) from base to surface.</p>"},{"location":"dimensions/#glmpy.dimensions.SimpleTruncatedPyramidWaterBody.get_surface_areas","title":"<code>get_surface_areas()</code>","text":"<p>Calculates surface areas.</p> <p>Returns the surface area of the water body at each height increment.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Name Type Description <code>surface_areas</code> <code>list</code> <p>Surface area of water body (m^3) at each metre height increment.</p>"},{"location":"dimensions/#glmpy.dimensions.SimpleTruncatedPyramidWaterBody.get_volumes","title":"<code>get_volumes()</code>","text":"<p>Calculates volumes.</p> <p>Returns the volume of the water body at each height increment.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Name Type Description <code>volume</code> <code>list</code> <p>The volume of water body (m^3) at each metre height increment.</p>"},{"location":"farm-dam-tutorial/","title":"Tutorials","text":""},{"location":"farm-dam-tutorial/#farm-dam","title":"Farm Dam","text":""},{"location":"farm-dam-tutorial/#introduction","title":"Introduction","text":"<p>In this tutorial, you will use <code>glmpy</code> to construct a simple model of a farm dam in the Western Australian (WA) Wheatbelt. The WA Wheatbelt is a semi-arid agricultural region dominated by rain-fed cropping and livestock production. Farm dams play a crucial role in storing fresh water for irrigation and animal consumption during the dry summer months. Climate change is warming the Wheatbelt and increasingly disrupting the winter rainfall patterns that fill farm dams. When dams dry out, the impact to farmers and animals can be servere. Modelling the water balance of these small water bodies is important to minimise their risk of failure under a drying climate.</p> <p>In the map below, you can see the dam is connected to a large catchment area. These catchments are often constructed up-hill from the dam and consist of a compacted clay surface. This design increases runoff during rainfall events and channels the water into the dam. To accurately model the dam, we will need to incorporate the inflows from this catchment.</p>"},{"location":"farm-dam-tutorial/#model-setup","title":"Model setup","text":"<p>Let's start building the model. <code>glmpy</code> provides a set of classes in the <code>nml</code> module that can be used to construct the GLM namelist file (<code>.nml</code>). The <code>.nml</code> file is simply a text file that contains a set of parameters which configure the model. These parameters are grouped into different components that each configure different aspects of the model. For every component, there is a corresponding class in the <code>nml</code> module that you can use to construct the namelist file, e.g., the <code>NMLMeteorology</code> class configures the <code>&amp;meteorology</code> parameters. Go ahead and import the <code>nml</code> module:</p> <pre><code>from glmpy import nml\n</code></pre> <p>The first component we will configure is the <code>&amp;setup</code> component. These parameters control the model layers. GLM is a 1-D model that simulates a water body as a vertical series of layers. The number of layers, and their thickness, is dynamic. Layers will expand, contract, merge, and split in response to water and surface mass fluxes.  The <code>&amp;setup</code> component defines the initial state of these layers. The <code>NMLSetup</code> class constructor takes the following arguments:</p> <ul> <li><code>sim_name</code>: The name of your simulation</li> <li><code>max_layers</code>: The maximum number of layers that can be created during the simulation</li> <li><code>min_layer_vol</code>: The minimum volume of a layer in cubic metres</li> <li><code>min_layer_thick</code>: The minimum thickness of a layer in metres</li> <li><code>max_layer_thick</code>: The maximum thickness of a layer in metres</li> <li><code>density_model</code>: The equation used to calculate the density of water in each layer</li> <li><code>non_avg</code>: A flag to indicate whether the model should use non-averaged layers</li> </ul> <p>Let's initialise our model with a maximum of 100 layers. Each layer must contain at least 0.1 m3 of water and range in thickness from 0.01-1.0 m. By setting <code>density_model</code> to 1, we'll use a model from TEOS-10 that calculates the density as a function of local temperature and salinity. Finally, we'll set <code>non_avg</code> to <code>True</code> to indicate that we want to use non-averaged layers.</p> <pre><code>setup = nml.NMLSetup(\nsim_name='farm_dam',\nmax_layers=100,\nmin_layer_vol=0.1,\nmin_layer_thick=0.01,\nmax_layer_thick=1.0,\ndensity_model=1,\nnon_avg=True\n)\n</code></pre>"},{"location":"farm-dam-tutorial/#model-duration","title":"Model duration","text":"<p>Our model will run over a 10 year period from 2010 to 2020 at an hourly timestep. The <code>&amp;time</code> component defines the start and stop time of the simulation, the time step, and the time zone. We can use <code>NMLTime</code> class constructor to configure these properties:</p> <pre><code>time = nml.NMLTime(\ntimefmt=2,\nstart=\"2010-01-01 00:00:00\",\nstop=\"2020-12-31 00:00:00\",\ndt=3600,\ntimezone=8\n)\n</code></pre> <p>Here, we have specified the <code>timefmt</code> as <code>2</code> which configures GLM to accept <code>start</code> and <code>stop</code> times. Alternatively, a <code>timefmt=3</code> allows GLM to read the <code>num_days</code> parameter. The <code>start</code> and <code>stop</code> times are specified as strings in the format <code>YYYY-MM-DD HH:MM:SS</code>. The <code>dt</code> parameter is the time step in seconds (3600 seconds in an hour). The <code>timezone</code> parameter is the time zone offset from UTC in hours.</p>"},{"location":"farm-dam-tutorial/#dam-morphometry","title":"Dam morphometry","text":"<p>Next, we'll define the dam morphometry, i.e., the physical dimensions that capture the shape of the water body. GLM records the morphometry of a water body by a list of height and surface area pairs. The heights are vertical distances from the bottom of the water body to the surface. Similarly, the surface areas are the horizontal area of the water body at the each height increment. The number of height/surface-area pairs you need to provide largely depends on how complex the morphometry is. For dams, the morphometry is simple. Most farm dams often resembles an truncated pyramid that has been inverted. Conveniently, <code>glmpy</code> provides a <code>SimpleTruncatedPyramidWaterBody</code> class in the <code>dimensions</code> module to easily calculate the height/surface-area pairs!</p> <p><pre><code>from glmpy import dimensions\n</code></pre> The <code>SimpleTruncatedPyramidWaterBody</code> constructor takes the following arguments:</p> <ul> <li><code>height</code>: The height (i.e., the depth) of the dam in metres.</li> <li><code>surface_width</code>: The width of the dam surface in metres.</li> <li><code>surface_length</code>: The length of the dam surface in metres.</li> <li><code>side_slope</code>: The rise over run of the dam side slopes</li> </ul> <p> </p> <p>Three of these arguments are known from the information on our map: <code>height</code>, <code>surface_width</code>, and <code>surface_length</code>. The <code>side_slope</code> is unknown so here we will make an assumption. Farm dams in the WA Wheatbelt are typically constructed with a side slope of 3:1. This means the dam slopes 3 metres vertically for every 1 metre horizontally. Based on this assumption we can now construct the <code>SimpleTruncatedPyramidWaterBody</code> object.</p> <pre><code>dam_morphometry = dimensions.SimpleTruncatedPyramidWaterBody(\nheight=5,\nsurface_width=40,\nsurface_length=62,\nside_slope=3\n)\n</code></pre> <p>By calling the  <code>get_heights()</code> and <code>get_surface_areas()</code> method on the <code>dam_morphometry</code> object you can return a list of height/surface-area pairs.</p> <pre><code>dam_morphometry.get_heights()\n</code></pre> <pre><code>[-5, -4, -3, -2, -1, 0]\n</code></pre> <pre><code>dam_morphometry.get_surface_areas()\n</code></pre> <pre><code>[2151.111, 2215.111, 2280.0, 2345.774, 2412.444, 2480.0]\n</code></pre> <p>We now have the morphometry of our dam! Let's use these values as inputs to the <code>NMLMorphometry</code> constructor. We'll need to set the following arguments:</p> <ul> <li><code>lake_name</code>: The name of the water body</li> <li><code>latitude</code>: The latitude of the water body</li> <li><code>longitude</code>: The longitude of the water body</li> <li><code>base_elev</code>: The elevation of the bottom of the water body</li> <li><code>crest_elev</code>: The elevation of the top of the water body</li> <li><code>bsn_len</code>: The surface length of the water body in metres</li> <li><code>bsn_wid</code>: The surface width of the water body in metres</li> <li><code>A</code>: A list of surface areas. We just calculated this!</li> <li><code>H</code>: A list of heights. We just calculated this!</li> </ul> <p><code>latitude</code> and <code>longitude</code> are easy, just check the map! What about <code>base_elev</code> and <code>crest_elev</code>? On this farm in the Wheatbelt we're 332 m above sea level. We'll set the <code>crest_elev</code> to <code>332</code>, and the <code>base_elev</code> to <code>332 - 5</code>, i.e., minus the dam depth. <code>bsn_wid</code> and <code>bsn_len</code> are the surface dimensions of the dam while <code>A</code> and <code>H</code> are values we calculated from the <code>dam_morphometry</code> object.</p> <pre><code>morphometry = nml.NMLMorphometry(\nlake_name = \"Farm dam\",\nlatitude = -32.474,\nlongitude = 116.988,\nbase_elev = 327,\ncrest_elev = 332,\nbsn_len = 62,\nbsn_wid = 40,\nH = dam_morphometry.get_heights(),\nA = dam_morphometry.get_surface_areas()\n)\n</code></pre>"},{"location":"farm-dam-tutorial/#initial-profiles","title":"Initial profiles","text":"<p>Let's fill up the dam! The <code>&amp;init_profiles</code> component of the GLM <code>.nml</code> file defines the initial state of water in the dam. We provide the initial water level (<code>lake_depth</code>), the water quality variables we want to simulate, and a set of depths where we can set the initialise certain conditions in the water profile.</p> <p>In this simulation, we're only interested in the water balance of our farm dam so we'll ignore the water quality variables. Our dam will start with 4 m of water and we'll set two depths at which we we'll initialise water temperature/salinity. The first depth will be at 1 m and the second at 3 m. We'll set the temperature and salinity at both depths to 18 \u00b0C and 0 ppt, respectively.</p> <pre><code>init_profiles = nml.NMLInitProfiles(\nlake_depth = 4,\nnum_depth = 2,\nthe_depths = [1, 3],\nthe_temps = [18.0, 18.0],\nthe_sals = [0.0, 0.0]\n)\n</code></pre>"},{"location":"farm-dam-tutorial/#meteorology","title":"Meteorology","text":"<p>To setup the meteorology component of the <code>.nml</code> file we need some nearby data on rainfall and temperature for each day of our simulation. Click here to download some pre-prepared data from the Bureau of Meteorology's weather station at the nearby town of Pingelly:</p> <p>Inspecting the CSV, you'll see daily observations from <code>2010-01-01 00:00:00</code> to <code>2020-12-31 00:00:00</code>:</p> date temperature rainfall 2010-01-01 00:00:00 29.5 0.0 2010-01-02 00:00:00 33.4 0.0 2010-01-03 00:00:00 38.6 0.0 2010-01-04 00:00:00 32.2 0.0 2010-01-05 00:00:00 37.2 0.0 <pre><code>meteorology = nml.NMLMeteorology(\nmet_sw = True,\nmeteo_fl = 'path/to/dam_tutorial_met_data.csv',\nsubdaily = False,\ntime_fmt = 'YYYY-MM-DD hh:mm:ss',\n???\n)\n</code></pre>"},{"location":"farm-dam-tutorial/#catchment-inflows","title":"Catchment inflows","text":"<p>Let's now return to the large catchment mentioned at the beginning of this tutorial. During a rainfall event, this catchment captures additional inputs from beyond the spatial extent of the dam. This can be accounted for by configuring the <code>&amp;inflows</code> component of the <code>.nml</code>. Catchment inflows are a function of the catchment area, rainfall, and a runoff threshold. The <code>NMLInflows</code> class expects a CSV with inflows pre-calculated for each day of the simulation. We'll use some of the additional functionality in <code>glmpy</code> to calculate this timeseries.</p> <p>Start by importing the <code>inflows</code> module:</p> <pre><code>from glmpy import inflows\n</code></pre> <p>The <code>CatchmentInflows</code> class will calculate daily inflows from the catchment area and our meteorological data. Dam catchments typically start producing runoff when rainfall exceeds 8 mm.</p> <pre><code>inflows = inflows.CatchmentInflows(\ninput_type = 'dataframe',\nmet_data = met_data,\ncatchment_area = 32000,\nrunoff_threshold = 0.008,\nprecip_col = 'rainfall',\ndate_time_col = 'time'\n)\n</code></pre>"},{"location":"how-to/","title":"How-to","text":""},{"location":"how-to/#nml","title":"NML","text":"<p>Begin by importing the <code>nml</code> module from <code>glmpy</code>:</p> <pre><code>from glmpy import nml\n</code></pre>"},{"location":"how-to/#setting-paramters","title":"Setting paramters","text":"<p>Parameters for each block in a <code>.nml</code> file can either be passed to the respective class as keyword arguments or as a dictionary object. For example, the <code>setup</code> block can be configured with the <code>NMLSetup</code> class as follows:</p> <pre><code>my_setup = nml.NMLSetup(\nsim_name='GLMSimulation',\nmax_layers=500,\nmin_layer_vol=0.5,\nmin_layer_thick=0.15,\nmax_layer_thick=0.5,\ndensity_model=1,\nnon_avg=True\n)\n</code></pre> <p>or as a dictionary object with the <code>set_attributes()</code> method:</p> <pre><code>my_setup = nml.NMLSetup()\nsetup_params = {\n'sim_name': 'GLMSimulation',\n'max_layers': 500,\n'min_layer_vol': 0.5,\n'min_layer_thick': 0.15,\n'max_layer_thick': 0.5,\n'density_model': 1,\n'non_avg': True\n}\nmy_setup.set_attributes(setup_params)\n</code></pre> <p>Refer to the API Reference for detailed information about the parameters for each block.</p>"},{"location":"how-to/#writing-the-nml-file","title":"Writing the <code>.nml</code> file","text":"<p>At a minimum, the GLM namelist file (<code>.nml</code>) requires model parameters set for the following blocks:</p> <ul> <li><code>setup</code> with the <code>NMLSetup</code> class</li> <li><code>morphometry</code> with the <code>NMLMorphometry</code> class</li> <li><code>time</code> with the <code>NMLTime</code> class</li> <li><code>init_profiles</code> with the <code>NMLInitProfiles</code> class</li> </ul> <p>The configured blocks can then be combined into a <code>.nml</code> file with the <code>NML</code> class:</p> <pre><code>my_nml = nml.NML(\nsetup=my_setup,\nmorphometry=my_morphometry,\ntime=my_time,\ninit_profiles=my_init_profiles\n)\n</code></pre> <p>To write the <code>.nml</code> file to disk, use the <code>write_nml()</code> method:</p> <pre><code>my_nml.write_nml(nml_file_path = 'my_nml.nml')\n</code></pre>"},{"location":"how-to/#calculating-the-morphometry-for-simple-water-bodies","title":"Calculating the morphometry for simple water bodies","text":"<p>For simple water bodies, <code>glmpy</code> provides some classes to conveniently calculate the <code>H</code> and <code>A</code> (height and surface area) parameters for the <code>NMLMorphometry</code> class.</p> <p>The <code>SimpleTruncatedPyramidWaterBody</code> class can be used for pyramidal water bodies with a rectangular base:</p> <p> </p> <pre><code>from glmpy import dimensions\nmy_dimensions = SimpleTruncatedPyramidWaterBody(\nheight = 3,\nsurface_width = 5,\nsurface_length =  5,\nside_slop = 3\n)\n</code></pre> <p>Heights and surface areas can be then returned with the <code>get_heights()</code> and <code>get_surface_areas()</code> methods:</p> <pre><code>my_heights = my_dimensions.get_heights()\nmy_surface_areas = my_dimensions.get_surface_areas()\n</code></pre>"},{"location":"how-to/#json","title":"JSON","text":""},{"location":"how-to/#converting-json-to-nml","title":"Converting JSON to <code>.nml</code>","text":"<p>GLM parameters stored in a JSON format can be converted to a <code>.nml</code> file with the <code>JSONToNML</code> class.</p> <p>Consider the following JSON file:</p> <pre><code>{\n  \"&amp;glm_setup\": {\n    \"sim_name\": \"Sparkling Lake\",\n    \"max_layers\": 500,\n    \"min_layer_vol\": 0.5,\n    \"min_layer_thick\": 0.15,\n    \"max_layer_thick\": 0.5,\n    \"density_model\": 1,\n    \"non_avg\": true\n  },\n  \"&amp;morphometry\": {\n    \"lake_name\": \"Sparkling\",\n    \"latitude\": 46.00881,\n    \"longitude\": -89.69953,\n    \"crest_elev\": 320.0,\n    \"bsn_len\": 901.0385,\n    \"bsn_wid\": 901.0385,\n    \"bsn_vals\": 15,\n    \"H\": [301.712, 303.018285714286, 304.324571428571, 305.630857142857, 306.937142857143, 308.243428571429, 309.549714285714, 310.856, 312.162285714286, 313.468571428571, 314.774857142857, 316.081142857143, 317.387428571429, 318.693714285714, 320, 321],\n    \"A\": [0, 45545.8263571429, 91091.6527142857, 136637.479071429, 182183.305428571, 227729.131785714, 273274.958142857, 318820.7845, 364366.610857143, 409912.437214286, 455458.263571429, 501004.089928571, 546549.916285714, 592095.742642857, 637641.569, 687641.569]\n  },\n  \"&amp;time\": {\n    \"timefmt\": 3,\n    \"start\": \"1980-04-15\",\n    \"stop\": \"2012-12-10\",\n    \"dt\": 3600,\n    \"timezone\": -6,\n    \"num_days\": 730\n  },\n  \"&amp;init_profiles\": {\n    \"lake_depth\": 18.288,\n    \"num_depths\": 3,\n    \"the_depths\": [0, 0.2, 18.288],\n    \"the_temps\": [3, 4, 4],\n    \"the_sals\": [0, 0, 0],\n    \"num_wq_vars\": 6,\n    \"wq_names\": [\"OGM_don\", \"OGM_pon\", \"OGM_dop\", \"OGM_pop\", \"OGM_doc\", \"OGM_poc\"],\n    \"wq_init_vals\": [1.1, 1.2, 1.3, 1.2, 1.3, 2.1, 2.2, 2.3, 1.2, 1.3, 3.1, 3.2, 3.3, 1.2, 1.3, 4.1, 4.2, 4.3, 1.2, 1.3, 5.1, 5.2, 5.3, 1.2, 1.3, 6.1, 6.2, 6.3, 1.2, 1.3]\n  }\n}\n</code></pre> <p>First, import the <code>JSONToNML</code> class:</p> <pre><code>from glmpy import JSONToNML\n</code></pre> <p>Then, create an instance of the <code>JSONToNML</code> class with the path to the JSON file:</p> <pre><code>json_file = JSONToNML('my_json_file.json')\n</code></pre> <p>Finally, use the <code>get_nml_attributes()</code> method to get the attributes for each block. This can be applied in the context of the <code>NML</code> class to create a <code>.nml</code> file:</p> <pre><code>nml = nml.NML(\nsetup=json_file.get_nml_attributes(\"&amp;glm_setup\"),\nmorphometry=json_file.get_nml_attributes(\"&amp;morphometry\"),\ntime=json_file.get_nml_attributes(\"&amp;time\"),\ninit_profiles=json_file.get_nml_attributes(\"&amp;init_profiles\")\n)\nnml.write_nml(nml_file_path='glm3.nml')\n</code></pre>"},{"location":"how-to/#outflows","title":"Outflows","text":"<p>The <code>Outflow</code> class provides functionality for creating and modifying the <code>outflows.csv</code>.</p> <pre><code>from glmpy import outflows\n</code></pre>"},{"location":"how-to/#setting-up-outflows","title":"Setting up outflows","text":"<p>The duration of the <code>outflows.csv</code> is set with the <code>start_date</code> and <code>end_date</code> parameters. These must match the <code>start</code> and <code>stop</code> parameters used to configure <code>time</code> block with <code>NMLTime</code>.</p> <p>An optional <code>base_flow</code> parameter can be set for constant outflows.</p> <pre><code>my_outflows = Outflows(\nstart_date = '1997-01-01',\nend_date = '1997-01-11',\nbase_flow = 0.0\n)\n</code></pre>"},{"location":"how-to/#set-outflows-for-specific-dates","title":"Set outflows for specific dates","text":"<p>By default, the <code>Outflows</code> class sets outflows to zero for the enitre simulation period. To set outflows for specific dates, use the <code>set_discrete_outflows()</code> method:</p> <pre><code>my_outflows.set_outflows(\ndates = ['1997-01-01', '1997-01-05', '1997-01-10'],\noutflows = [3.5, 1.2, 4.7]\n)\n</code></pre>"},{"location":"how-to/#set-outflows-for-a-date-range","title":"Set outflows for a date range","text":"<p>Constant outflows can be set for a date range with the <code>set_continuous_outflows()</code> method:</p> <pre><code>my_outflows.set_continuous_outflows(\nstart_date = '1997-01-06',\nend_date = '1997-01-09',\noutflow = 2.5\n)\n</code></pre>"},{"location":"how-to/#inspecting-outflows","title":"Inspecting outflows","text":"<p>The <code>get_outflows()</code> method will return a <code>pandas.DataFrame</code> object with the outflows for the simulation period:</p> <pre><code>my_outflows.get_outflows()\n</code></pre>"},{"location":"how-to/#writing-outflows-to-disk","title":"Writing outflows to disk","text":"<p>Once the outflows have been defined, they can be saved to disk as a <code>.csv</code> with the <code>write_outflows()</code> method:</p> <pre><code>my_outflows.write_outflows(outflow_file_path = 'my_outflows.csv')\n</code></pre>"},{"location":"how-to/#inflows","title":"Inflows","text":"<p>Inflows define any additional inputs to the simulated water body.</p> <pre><code>from glmpy import inflows\n</code></pre>"},{"location":"how-to/#calculating-inflows-from-catchment-runoff","title":"Calculating inflows from catchment runoff","text":"<p>The <code>CatchmentRunoffInflows</code> class provides functionality for calculating inflows from catchment runoff. The amount of runoff is calculated as a product of the catchment area, precipitation, and a runoff coefficient/threshold.</p> <p>First, an existing <code>.csv</code> file with precipitation data must be available on disk or loaded into a <code>pandas.DataFrame</code> object:</p> <pre><code>met_data = pd.DataFrame({\n'Date': pd.date_range(\nstart='1997-01-01',\nend='2004-12-31',\nfreq='H'),\n'Rain': 10\n})\nmet_data.to_csv('met_data.csv')\n</code></pre> <p>Next, the <code>CatchmentRunoffInflows</code> class can be initiated with the path to the precipitation data. Provide the column names for the date and precipitation data (<code>date_time_col</code> and <code>precip_col</code> respectively). The <code>runoff_coeff</code> or <code>runoff_threshold</code> parameters can be used to set a constant runoff coefficient/threshold for the area of the catchment (<code>catchment_area</code>):</p> <pre><code>my_inflows = CatchmentRunoffInflows(\ninput_type = 'file',\npath_to_met_csv = 'met_data.csv',\ncatchment_area = 1000, # a 1000 m^2 catchment area\nrunoff_threshold = 10.0, # a 10mm runoff threshold\nprecip_col = 'Rain',\ndate_time_col = 'Date',\ndate_time_format= '%Y-%m-%d %H:%M:%S'\n)\n</code></pre>"},{"location":"how-to/#inspect-the-catchment-inflows","title":"Inspect the catchment inflows","text":"<p><code>CatchmentRunoffInflows</code> calculates a inflows timeseries at a daily frequency with units of m3/sec. You can return the timeseries as a Pandas dataframe by calling the <code>get_inflows()</code> method:</p> <pre><code>my_inflows.get_inflows()\n</code></pre> <pre><code>                flow\ntime\n1997-01-01  2.777662\n1997-01-02  2.777662\n1997-01-03  2.777662\n1997-01-04  2.777662\n1997-01-05  2.777662\n...              ...\n2004-12-27  2.777662\n2004-12-28  2.777662\n2004-12-29  2.777662\n2004-12-30  2.777662\n2004-12-31  0.115625\n\n[2922 rows x 1 columns]\n</code></pre>"},{"location":"how-to/#writing-catchment-inflows-to-disk","title":"Writing catchment inflows to disk","text":"<p>GLM inflows must be recorded at daily timesteps. As catchment inflows are often calculated directly from high resolution precipitation data, the <code>write_inflows</code> method can be used resample the inflows to daily timesteps when writing them to disk:</p> <pre><code>my_inflows.write_inflows(\npath_to_inflow_csv = \"runoff.csv\"\n)\n</code></pre>"},{"location":"inflows/","title":"Inflows","text":""},{"location":"inflows/#glmpy.inflows.CatchmentRunoffInflows","title":"<code>CatchmentRunoffInflows</code>","text":"<p>Calculate runoff inflows from a catchment.</p> <p>Generates an inflows timeseries by calculating catchment runoff from a pandas Dataframe of precipitation data. Requires a catchment area, a runoff coefficient or threshold, and a precipitation timeseries in either hourly or daily timesteps. Inflows are calculated at the same timestep as the precipitation data but in units of m^3/s. <code>CatchmentRunoffInflows</code> provides methods to return the calculated inflows timeseries as a pandas DataFrame or to write the timeseries to a CSV.</p> <p>Attributes:</p> Name Type Description <code>met_data</code> <code>Union[pd.DataFrame, None]</code> <p>A pandas DataFrame of meteorological data.</p> <code>precip_col</code> <code>str</code> <p>Name of the column in the DataFrame containing precipitation data in m/day or m/hour.</p> <code>date_time_col</code> <code>str</code> <p>Name of the column in the DataFrame containing datetime data.</p> <code>catchment_area</code> <code>float</code> <p>Area of the catchment in square meters.</p> <code>runoff_coef</code> <code>Union[float, None]</code> <p>Runoff coefficient for the catchment. The fraction of rainfall that will result in runoff. Either <code>runoff_coef</code> or <code>runoff_threshold</code> must be provided.</p> <code>runoff_threshold</code> <code>Union[float, None]</code> <p>Runoff threshold for the catchment. The amount of rainfall in mm to generate runoff. Either <code>runoff_coef</code> or <code>runoff_threshold</code> must be provided.</p> <p>Examples:</p> <p>Generate a daily timeseries of rainfall:</p> <pre><code>&gt;&gt;&gt; daily_met_data = pd.DataFrame({\n... 'Date': pd.date_range(\n...     start='1997-01-01',\n...     end='2004-12-31',\n...     freq='24H'),\n... 'Rain': 0.024 #m per day\n... })\n</code></pre> <p>Calculate inflows with a 50% runoff coefficient and a 1000 m^2 catchment area:</p> <pre><code>&gt;&gt;&gt; inflows_data = inflows.CatchmentRunoffInflows(\n...     met_data = daily_met_data,\n...     catchment_area = 1000,\n...     runoff_coef = 0.5,\n...     precip_col = 'Rain',\n...     date_time_col = 'Date'\n... )\n&gt;&gt;&gt; inflows_data.get_inflows()\n</code></pre> <p>Generate a hourly timeseries of rainfall:</p> <pre><code>&gt;&gt;&gt; hourly_met_data = pd.DataFrame({\n... 'Date': pd.date_range(\n...     start='1997-01-01',\n...     end='2004-12-31',\n...     freq='1H'),\n... 'Rain': 0.001\n... })\n</code></pre> <p>Calculate inflows with a 50% runoff coefficient and a 1000 m^2 catchment area:</p> <pre><code>&gt;&gt;&gt; inflows_data = inflows.CatchmentRunoffInflows(\n...     met_data = hourly_met_data,\n...     catchment_area = 1000,\n...     runoff_coef = 0.5,\n...     precip_col = 'Rain',\n...     date_time_col = 'Date'\n... )\n&gt;&gt;&gt; inflows_data.get_inflows()\n</code></pre>"},{"location":"inflows/#glmpy.inflows.CatchmentRunoffInflows.get_inflows","title":"<code>get_inflows()</code>","text":"<p>Get the inflows timeseries.</p> <p>Returns a pandas dataframe of the calculated catchment runoff inflows.</p> <p>Returns:</p> Name Type Description <code>inflows</code> <code>pd.DataFrame</code> <p>DataFrame of inflow data.</p> <p>Examples:</p> <p>Generate a hourly timeseries of rainfall:</p> <pre><code>&gt;&gt;&gt; hourly_met_data = pd.DataFrame({\n... 'Date': pd.date_range(\n...     start='1997-01-01',\n...     end='2004-12-31',\n...     freq='1H'),\n... 'Rain': 0.001\n... })\n</code></pre> <p>Calculate inflows with a 50% runoff coefficient and a 1000 m^2 catchment area</p> <pre><code>&gt;&gt;&gt; inflows_data = inflows.CatchmentRunoffInflows(\n...     met_data = hourly_met_data,\n...     catchment_area = 1000,\n...     runoff_coef = 0.5,\n...     precip_col = 'Rain',\n...     date_time_col = 'Date'\n... )\n</code></pre> <p>Call <code>get_inflows</code> to return the inflows timeseries:</p> <pre><code>&gt;&gt;&gt; inflows_data.get_inflows()\n</code></pre>"},{"location":"inflows/#glmpy.inflows.CatchmentRunoffInflows.write_inflows","title":"<code>write_inflows(file_path)</code>","text":"<p>Write the inflow timeseries to a CSV file.</p> <p>Calculates catchment runoff inflows and writes the timeseries to a CSV.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the output CSV file.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import inflows\n&gt;&gt;&gt; daily_met_data = pd.DataFrame({\n...     'Date': pd.date_range(\n...         start='1997-01-01',\n...         end='2004-12-31',\n...         freq='24H'),\n...     'Rain': 0.024\n... })\n&gt;&gt;&gt; inflows_data = inflows.CatchmentRunoffInflows(\n...     met_data = daily_met_data,\n...     catchment_area = 1000,\n...     runoff_coef = 0.5,\n...     precip_col = 'Rain',\n...     date_time_col = 'Date'\n... )\n</code></pre> <p>Call <code>write_inflows</code> to write the inflows timeseries to a CSV:</p> <pre><code>&gt;&gt;&gt; inflows_data.write_inflows(file_path='runoff.csv')\n</code></pre>"},{"location":"json-to-nml/","title":"JSON","text":""},{"location":"json-to-nml/#glmpy.json.JSONToNML","title":"<code>JSONToNML</code>","text":"<p>Supports the reading of GLM configuration blocks in a json format.</p> <p>Reads and parses a json file into a dictionary. Dictionaries can then be used to set the attributes of the corresponding NML class. Useful for converting a json file of GLM parameters from a web application.</p> <p>Attributes:</p> Name Type Description <code>json_file</code> <code>str</code> <p>The path to the json file to be read.</p> <code>nml_file</code> <code>str</code> <p>The path to the nml file to be written.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import JSONToNML\n&gt;&gt;&gt; json_to_nml = JSONToNML(\"sparkling_lake.json\")\n</code></pre>"},{"location":"json-to-nml/#glmpy.json.JSONToNML.get_nml_attributes","title":"<code>get_nml_attributes(nml_block)</code>","text":"<p>Get the attributes for a GLM configuration block.</p> <p>Returns the attributes of a specified GLM configuration block as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>nml_block</code> <code>str</code> <p>The name of the GLM configuration block</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the attributes for a specified GLM configuration block.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import JSONToNML\n&gt;&gt;&gt; json = JSONToNML(\"sparkling_lake.json\")\n&gt;&gt;&gt; setup_dict = json.get_nml_attributes(\"&amp;glm_setup\")\n&gt;&gt;&gt; setup = nml.NMLSetup()\n&gt;&gt;&gt; setup.set_attributes(setup_dict)\n</code></pre>"},{"location":"json-to-nml/#glmpy.json.JSONToNML.get_nml_blocks","title":"<code>get_nml_blocks()</code>","text":"<p>Reads a json file of GLM configuration blocks and returns a list of the block names.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import JSONToNML\n&gt;&gt;&gt; json_to_nml = JSONToNML(\"config.json\")\n&gt;&gt;&gt; json_to_nml.get_nml_blocks()\n</code></pre>"},{"location":"json-to-nml/#glmpy.json.JSONToNML.read_json","title":"<code>read_json()</code>","text":"<p>Reads the json file and returns a dictionary.</p> <p>Reads a json file of GLM configuration blocks and returns a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import JSONToNML\n&gt;&gt;&gt; json_to_nml = JSONToNML(\"sparkling_lake.json\")\n&gt;&gt;&gt; json_to_nml.read_json()\n</code></pre>"},{"location":"nml/","title":"NML","text":""},{"location":"nml/#glmpy.nml.NML","title":"<code>NML</code>","text":"<p>Generate .nml files.</p> <p><code>.nml</code> files contain the parameters required for running a simulation with the General Lake Model (GLM). The <code>NML</code> class combines string representations of each component of a <code>.nml</code> file, e.g., <code>&amp;setup</code>, and <code>&amp;morphometry</code>. The file can be saved to disk with the<code>write_nml()</code> method.</p> <p>Attributes:</p> Name Type Description <code>setup</code> <code>str</code> <p>String representation of the <code>&amp;glm_setup</code> component of the .nml file. See <code>NMLSetup</code>. Required for every GLM simulation.</p> <code>morphometry</code> <code>str</code> <p>String representation of the <code>&amp;morphometry</code> component of the .nml file. See <code>NMLMorphometry</code>. Required for every GLM simulation.</p> <code>time</code> <code>str</code> <p>String representation of the <code>&amp;time</code> component of the .nml file. See <code>NMLTime</code>. Required for every GLM simulation.</p> <code>init_profiles</code> <code>str</code> <p>String representation of the <code>&amp;init_profiles</code> component of the .nml file. See <code>NMLInitProfiles</code>. Required for every GLM simulation.</p> <code>mixing</code> <code>Union[str, None]</code> <p>String representation of the <code>&amp;mixing</code> component of the .nml file. See <code>NMLMixing</code>. Default is None.</p> <code>output</code> <code>Union[str, None]</code> <p>String representation of the <code>&amp;output</code> component of the .nml file. See <code>NMLOutput</code>. Default is None.</p> <code>meteorology</code> <code>Union[str, None]</code> <p>String representation of the <code>&amp;meteorology</code> component of the .nml file. See <code>NMLMeteorology</code>. Default is None.</p> <code>light</code> <code>Union[str, None]</code> <p>String representation of the <code>&amp;light</code> component of the .nml file. See <code>NMLLight</code>. Default is None.</p> <code>bird_model</code> <code>Union[str, None]</code> <p>String representation of the <code>&amp;bird_model</code> component of the .nml file. See <code>NMLBirdModel</code>. Default is None.</p> <code>inflows</code> <code>Union[str, None]</code> <p>String representation of the <code>&amp;inflows</code> component of the .nml file. See <code>NMLInflows</code>. Default is None.</p> <code>outflows</code> <code>Union[str, None]</code> <p>String representation of the <code>&amp;outflows</code> component of the .nml file. See <code>NMLOutflows</code>. Default is None.</p> <code>sediment</code> <code>Union[str, None]</code> <p>String representation of the <code>&amp;sediment</code> component of the .nml file. See <code>NMLSediment</code>. Default is None.</p> <code>ice_snow</code> <code>Union[str, None]</code> <p>String representation of the <code>&amp;ice_snow</code> component of the .nml file. See <code>NMLIceSnow</code>. Default is None.</p> <code>wq_setup</code> <code>Union[str, None]</code> <p>String representation of the <code>&amp;wq_setup</code> component of the .nml file. See <code>NMLWQSetup</code>. Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; from glmpy import json\nRead a json file of GLM config data:\n&gt;&gt;&gt; json = JSONToNML(\"sparkling_lake.json\")\nFor each NML block, get the attributes from the json file:\n&gt;&gt;&gt; setup_dict = json.get_nml_attributes(\"&amp;glm_setup\")\n&gt;&gt;&gt; morphometry_dict = json.get_nml_attributes(\"&amp;morphometry\")\n&gt;&gt;&gt; time_dict = json.get_nml_attributes(\"&amp;time\")\n&gt;&gt;&gt; init_profiles_dict = json.get_nml_attributes(\"&amp;init_profiles\")\nInitialise an instance of each NML block class and set the attributes:\n&gt;&gt;&gt; setup = nml.NMLSetup()\n&gt;&gt;&gt; setup.set_attributes(setup_dict)\n&gt;&gt;&gt; morphometry=nml.NMLMorphometry()\n&gt;&gt;&gt; morphometry.set_attributes(morphometry_dict)\n&gt;&gt;&gt; time=nml.NMLTime()\n&gt;&gt;&gt; time.set_attributes(time_dict)\n&gt;&gt;&gt; init_profiles=nml.NMLInitProfiles()\n&gt;&gt;&gt; init_profiles.set_attributes(init_profiles_dict)\nInitialise the NML class with the NML block instances:\n&gt;&gt;&gt; nml = nml.NML(\n...     setup=setup,\n...     morphometry=morphometry,\n...     time=time,\n...     init_profiles=init_profiles\n... )\nWrite the .nml file:\n&gt;&gt;&gt; nml.write_nml(nml_file_path=\"sparkling.nml\")\n</code></pre>"},{"location":"nml/#glmpy.nml.NML.write_nml","title":"<code>write_nml(nml_file_path='glm3.nml')</code>","text":"<p>Write a .nml file.</p> <p>Write the <code>NML</code> instance to file with the .nml extension.</p> <p>Parameters:</p> Name Type Description Default <code>nml_file_path</code> <code>str</code> <p>File path to save .nml file, by default <code>glm3.nml</code>.</p> <code>'glm3.nml'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; nml.write_nml(nml_file_path=\"sparkling.nml\")\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLBase","title":"<code>NMLBase</code>","text":"<p>Base class for each NML block class.</p> <p>Provides the <code>set_attributes()</code> method for assigning a dictionary of attributes to any NML block class.</p> <p>Attributes:</p> Name Type Description <code>attrs_dict</code> <code>dict</code> <p>A dictionary containing the GLM configuration parameters as keys and the corresponding values to set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLBase\n&gt;&gt;&gt; from glmpy import NMLMorphometry\n&gt;&gt;&gt; morphometry_attrs={\n...         \"lake_name\": \"Example Lake'\",\n...         \"latitude\":  32,\n...         \"longitude\": 35,\n...         \"crest_elev\": -203.9,\n...         \"bsn_len\": 21000,\n...         \"bsn_wid\": 13000,\n...         \"max_layer_thick\": 0.1,\n...         \"density_model\": 1,\n...         \"bsn_vals\": \"3\",\n...         \"H\": [-252.9,  -251.9,  -250.9],\n...         \"A\": [0,  9250000,  15200000,],\n... }\n&gt;&gt;&gt; morphometry = NMLMorphometry()\n&gt;&gt;&gt; morphometry.set_attributes(attrs_dict=morphometry_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLBase.comma_sep_list","title":"<code>comma_sep_list(list_input, inverted_commas=False)</code>  <code>staticmethod</code>","text":"<p>Convert a Python list to a NML formatted comma separated string.</p> <p>If the list_input is None, None is returned. If inverted_commas is True, the list items are returned as strings with inverted commas.</p> <p>Parameters:</p> Name Type Description Default <code>list_input</code> <code>list</code> <p>A list of values.</p> required <code>inverted_commas</code> <code>bool</code> <p>If True, the list items are returned as strings with inverted commas.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A comma separated string for use in defining a NML block. Returns None if list_input is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLBase\n&gt;&gt;&gt; NMLBase.comma_sep_list([1, 2, 3], inverted_commas = False)\n'1, 2, 3'\n&gt;&gt;&gt; NMLBase.comma_sep_list([1, 2, 3], inverted_commas=True)\n\"'1', '2', '3'\"\n&gt;&gt;&gt; NMLBase.comma_sep_list(['a', 'b', 'c'], inverted_commas=True)\n\"'a', 'b', 'c'\"\n&gt;&gt;&gt; comma_sep_list(['a', 'b', 'c'], inverted_commas=False)\n'a, b, c'\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLBase.fortran_bool_string","title":"<code>fortran_bool_string(bool_input)</code>  <code>staticmethod</code>","text":"<p>Python boolean to Fortran boolean string.</p> <p>Convert a Python boolean, or a list of Python booleans, to a Fortran boolean string or a list of Fortran boolean strings.</p> <p>Parameters:</p> Name Type Description Default <code>bool_input</code> <code>Union[bool, List[bool], None]</code> <p>A Python boolean or a list of Python booleans.</p> required <p>Returns:</p> Type Description <code>Union[str, List[Union[str, None]], None]</code> <p>A Fortran boolean string or a list of Fortran boolean strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fortran_bool_string(True)\n'.true.'\n&gt;&gt;&gt; fortran_bool_string([True, False])\n['.true.', '.false.']\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLBase.set_attributes","title":"<code>set_attributes(attrs_dict)</code>","text":"<p>Set attributes for a NML block class.</p> <p>Set the attributes of any NML block class (e.g. <code>NMLSetup</code>, <code>NMLTime</code>) using a dictionary of attribute names and values.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary containing the attribute names as keys and the corresponding values to set.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLBase\n&gt;&gt;&gt; from glmpy import NMLMorphometry\n&gt;&gt;&gt; morphometry_attrs={\n...         \"lake_name\": \"Example Lake'\",\n...         \"latitude\":  32,\n...         \"longitude\": 35,\n...         \"crest_elev\": -203.9,\n...         \"bsn_len\": 21000,\n...         \"bsn_wid\": 13000,\n...         \"max_layer_thick\": 0.1,\n...         \"density_model\": 1,\n...         \"bsn_vals\": \"3\",\n...         \"H\": [-252.9,  -251.9,  -250.9],\n...         \"A\": [0,  9250000,  15200000,],\n... }\n&gt;&gt;&gt; morphometry = NMLMorphometry()\n&gt;&gt;&gt; morphometry.set_attributes(attrs_dict=morphometry_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLBirdModel","title":"<code>NMLBirdModel</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Define the <code>&amp;bird_model</code> block of a GLM simulation configuration.</p> <p>Used to configure surface irradiance based on the Bird Clear Sky Model (BCSM) (Bird, 1984). Attributes are set using the <code>set_attributes()</code> method and returned as a formatted string using the <code>__str__()</code> method.</p> <p>Attributes:</p> Name Type Description <code>AP</code> <code>Union[float, None]</code> <p>Atmospheric pressure (hPa). Default is None.</p> <code>Oz</code> <code>Union[float, None]</code> <p>Ozone concentration (atm-cm). Default is None.</p> <code>WatVap</code> <code>Union[float, None]</code> <p>Total Precipitable water vapor (atm-cm). Default is None.</p> <code>AOD500</code> <code>Union[float, None]</code> <p>Dimensionless Aerosol Optical Depth at wavelength 500 nm. Default is None.</p> <code>AOD380</code> <code>Union[float, None]</code> <p>Dimensionless Aerosol Optical Depth at wavelength 380 nm. Default is None.</p> <code>Albedo</code> <code>Union[float, None]</code> <p>Albedo of the surface used for Bird Model insolation calculation. Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLBirdModel\n&gt;&gt;&gt; bird_model = NMLBirdModel()\n&gt;&gt;&gt; my_bird_model = {\n&gt;&gt;&gt;     'AP': 973,\n&gt;&gt;&gt;     'Oz': 0.279,\n&gt;&gt;&gt;     'WatVap': 1.1,\n&gt;&gt;&gt;     'AOD500': 0.033,\n&gt;&gt;&gt;     'AOD380': 0.038,\n&gt;&gt;&gt;     'Albedo': 0.2\n&gt;&gt;&gt; }\n&gt;&gt;&gt; bird_model.set_attributes(my_bird_model)\n&gt;&gt;&gt; print(bird_model)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLBirdModel.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the <code>NMLBirdModel</code> object.</p> <p>Returns a <code>.nml</code> formatted string of the NMLBirdModel attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the <code>NMLBirdModel</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLBirdModel\n&gt;&gt;&gt; bird_model = NMLBirdModel()\n&gt;&gt;&gt; my_bird_model = {\n&gt;&gt;&gt;     'AP': 973,\n&gt;&gt;&gt;     'Oz': 0.279,\n&gt;&gt;&gt;     'WatVap': 1.1,\n&gt;&gt;&gt;     'AOD500': 0.033,\n&gt;&gt;&gt;     'AOD380': 0.038,\n&gt;&gt;&gt;     'Albedo': 0.2\n&gt;&gt;&gt; }\n&gt;&gt;&gt; bird_model.set_attributes(my_bird_model)\n&gt;&gt;&gt; print(bird_model)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLInflows","title":"<code>NMLInflows</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Define the <code>&amp;inflow</code> block of a GLM model.</p> <p>Used to configure the number/type of water inflows. Attributes are set using the <code>set_attributes()</code> method and returned as a formatted string using the <code>__str__()</code> method.</p> <p>Attributes:</p> Name Type Description <code>num_inflows</code> <code>Union[int, None]</code> <p>Number of inflows to be simulated in this simulation. Default is None.</p> <code>names_of_strms</code> <code>Union[List[str], None]</code> <p>Names of each inflow.</p> <code>subm_flag</code> <code>Union[List[bool], None]</code> <p>Switch indicating if the inflow I is entering as a submerged input. Default is None.</p> <code>strm_hf_angle</code> <code>Union[List[float], None]</code> <p>Angle describing the width of an inflow river channel (\"half angle\"). Default is None.</p> <code>strmbd_slope</code> <code>Union[List[float], None]</code> <p>Slope of the streambed / river thalweg for each river (degrees). Default is None.</p> <code>strmbd_drag</code> <code>Union[List[float], None]</code> <p>Drag coefficient of the river inflow thalweg, to calculate entrainment during insertion. Default is None.</p> <code>coef_inf_entrain</code> <code>Union[List[float], None]</code> <p>Default is None.</p> <code>inflow_factor</code> <code>Union[List[float], None]</code> <p>Scaling factor that can be applied to adjust the provided input data. Default is None.</p> <code>inflow_fl</code> <code>Union[List[str], None]</code> <p>Filename(s) of the inflow CSV boundary condition files. Default is None.</p> <code>inflow_varnum</code> <code>Union[int, None]</code> <p>Number of variables being listed in the columns of inflow_fl (comma-separated list). Default is None.</p> <code>inflow_vars</code> <code>Union[List[str], None]</code> <p>Names of the variables in the inflow_fl. Default is None.</p> <code>time_fmt</code> <code>Union[str, None]</code> <p>Time format of the 1st column in the inflow_fl. Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLInflows\n&gt;&gt;&gt; inflows = NMLInflows()\n&gt;&gt;&gt; my_inflows = {\n&gt;&gt;&gt;     'num_inflows': 6,\n&gt;&gt;&gt;     'names_of_strms': ['Inflow1','Inflow2','Inflow3','Inflow4','Inflow5','Inflow6'],\n&gt;&gt;&gt;     'subm_flag': [False, False, False, True, False, False],\n&gt;&gt;&gt;     'strm_hf_angle': [85.0, 85.0, 85.0, 85.0, 85.0, 85.0],\n&gt;&gt;&gt;     'strmbd_slope': [4.0, 4.0, 4.0, 4.0, 4.0, 4.0],\n&gt;&gt;&gt;     'strmbd_drag': [0.0160, 0.0160, 0.0160, 0.0160, 0.0160, 0.0160],\n&gt;&gt;&gt;     'inflow_factor': [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n&gt;&gt;&gt;     'inflow_fl': ['bcs/inflow_1.csv', 'bcs/inflow_2.csv', 'bcs/inflow_3.csv', 'bcs/inflow_4.csv', 'bcs/inflow_5.csv', 'bcs/inflow_6.csv'],\n&gt;&gt;&gt;     'inflow_varnum': 3,\n&gt;&gt;&gt;     'inflow_vars': ['FLOW','TEMP','SALT'],\n&gt;&gt;&gt;     'coef_inf_entrain': [0.0],\n&gt;&gt;&gt;     'time_fmt': 'YYYY-MM-DD hh:mm:ss'\n&gt;&gt;&gt; }\n&gt;&gt;&gt; inflows.set_attributes(my_inflows)\n&gt;&gt;&gt; print(inflows)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLInflows.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the <code>NMLInflows</code> object.</p> <p>Returns a <code>.nml</code> formatted string of the <code>NMLInflows</code> attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the <code>NMLInflows</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLInflows\n&gt;&gt;&gt; inflows = NMLInflows()\n&gt;&gt;&gt; my_inflows = {\n&gt;&gt;&gt;     'num_inflows': 6,\n&gt;&gt;&gt;     'names_of_strms': ['Inflow1','Inflow2','Inflow3','Inflow4','Inflow5','Inflow6'],\n&gt;&gt;&gt;     'subm_flag': [False, False, False, True, False, False],\n&gt;&gt;&gt;     'strm_hf_angle': [85.0, 85.0, 85.0, 85.0, 85.0, 85.0],\n&gt;&gt;&gt;     'strmbd_slope': [4.0, 4.0, 4.0, 4.0, 4.0, 4.0],\n&gt;&gt;&gt;     'strmbd_drag': [0.0160, 0.0160, 0.0160, 0.0160, 0.0160, 0.0160],\n&gt;&gt;&gt;     'inflow_factor': [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n&gt;&gt;&gt;     'inflow_fl': ['bcs/inflow_1.csv', 'bcs/inflow_2.csv', 'bcs/inflow_3.csv', 'bcs/inflow_4.csv', 'bcs/inflow_5.csv', 'bcs/inflow_6.csv'],\n&gt;&gt;&gt;     'inflow_varnum': 3,\n&gt;&gt;&gt;     'inflow_vars': ['FLOW','TEMP','SALT'],\n&gt;&gt;&gt;     'coef_inf_entrain': [0.0],\n&gt;&gt;&gt;     'time_fmt': 'YYYY-MM-DD hh:mm:ss'\n&gt;&gt;&gt; }\n&gt;&gt;&gt; inflows.set_attributes(my_inflows)\n&gt;&gt;&gt; print(inflows)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLInitProfiles","title":"<code>NMLInitProfiles</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Define the <code>&amp;init_profiles</code> block of a GLM model.</p> <p>Used to configure the initial state of various water quality variables at specific depths in the water body. Attributes are set using the <code>set_attributes()</code> method and returned as a formatted string using the <code>__str__()</code> method.</p> <p>Attributes:</p> Name Type Description <code>lake_depth</code> <code>Union[float, None]</code> <p>Initial lake height/depth (m). Default is NOne.</p> <code>num_depths</code> <code>Union[int, None]</code> <p>Number of depths provided for initial profiles. Default is None.</p> <code>the_depths</code> <code>Union[List[float], None]</code> <p>The depths of the initial profile points (m). Default is None.</p> <code>the_temps</code> <code>Union[List[float], None]</code> <p>The temperature (C) at each of the initial profile points. Default is None.</p> <code>the_sals</code> <code>Union[List[float], None]</code> <p>The salinity (ppt) at each of the initial profile points. Default is None.</p> <code>num_wq_vars</code> <code>Union[int, None]</code> <p>Number of non GLM (ie FABM or AED2) variables to be initialised. Default is None.</p> <code>wq_names</code> <code>Union[List[str], None]</code> <p>Names of non GLM (ie FABM or AED2) variables to be initialised. Default is None.</p> <code>wq_init_vals</code> <code>Union[List[str], None]</code> <p>Array of WQ variable initial data (rows = vars; cols = depths). Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLSetup\n&gt;&gt;&gt; init_profiles = NMLInitProfiles()\n&gt;&gt;&gt; my_init_profile = {\n&gt;&gt;&gt;     \"lake_depth\": 43,\n&gt;&gt;&gt;     \"num_depths\": 3,\n&gt;&gt;&gt;     \"the_depths\": [1, 20, 40],\n&gt;&gt;&gt;     \"the_temps\": [18.0, 18.0, 18.0],\n&gt;&gt;&gt;     \"the_sals\": [0.5, 0.5, 0.5],\n&gt;&gt;&gt;     \"num_wq_vars\": 6,\n&gt;&gt;&gt;     \"wq_names\": [\"OGM_don\", \"OGM_pon\", \"OGM_dop\", \"OGM_pop\", \"OGM_doc\", \"OGM_poc\"],\n&gt;&gt;&gt;     \"wq_init_vals\": [1.1, 1.2, 1.3, 1.2, 1.3,\n&gt;&gt;&gt;                     2.1, 2.2, 2.3, 1.2, 1.3,\n&gt;&gt;&gt;                     3.1, 3.2, 3.3, 1.2, 1.3,\n&gt;&gt;&gt;                     4.1, 4.2, 4.3, 1.2, 1.3,\n&gt;&gt;&gt;                     5.1, 5.2, 5.3, 1.2, 1.3,\n&gt;&gt;&gt;                     6.1, 6.2, 6.3, 1.2, 1.3]\n&gt;&gt;&gt; }\n&gt;&gt;&gt; init_profile.set_attributes(my_init_profile)\n&gt;&gt;&gt; print(init_profile)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLInitProfiles.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the <code>NMLInitProfiles</code> object.</p> <p>Returns a <code>.nml</code> formatted string of the <code>NMLInitProfiles</code> attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the <code>NMLInitProfiles</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLSetup\n&gt;&gt;&gt; init_profiles = NMLInitProfiles()\n&gt;&gt;&gt; my_init_profile = {\n&gt;&gt;&gt;     \"lake_depth\": 43,\n&gt;&gt;&gt;     \"num_depths\": 3,\n&gt;&gt;&gt;     \"the_depths\": [1, 20, 40],\n&gt;&gt;&gt;     \"the_temps\": [18.0, 18.0, 18.0],\n&gt;&gt;&gt;     \"the_sals\": [0.5, 0.5, 0.5],\n&gt;&gt;&gt;     \"num_wq_vars\": 6,\n&gt;&gt;&gt;     \"wq_names\": [\"OGM_don\", \"OGM_pon\", \"OGM_dop\", \"OGM_pop\", \"OGM_doc\", \"OGM_poc\"],\n&gt;&gt;&gt;     \"wq_init_vals\": [1.1, 1.2, 1.3, 1.2, 1.3,\n&gt;&gt;&gt;                     2.1, 2.2, 2.3, 1.2, 1.3,\n&gt;&gt;&gt;                     3.1, 3.2, 3.3, 1.2, 1.3,\n&gt;&gt;&gt;                     4.1, 4.2, 4.3, 1.2, 1.3,\n&gt;&gt;&gt;                     5.1, 5.2, 5.3, 1.2, 1.3,\n&gt;&gt;&gt;                     6.1, 6.2, 6.3, 1.2, 1.3]\n&gt;&gt;&gt; }\n&gt;&gt;&gt; init_profile.set_attributes(my_init_profile)\n&gt;&gt;&gt; print(init_profile)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLLight","title":"<code>NMLLight</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Define the <code>&amp;light</code> block of a GLM model.</p> <p>Used to configure the how light will penetrates the water body. Attributes are set using the <code>set_attributes()</code> method and returned as a formatted string using the <code>__str__()</code> method.</p> <p>Attributes:</p> Name Type Description <code>light_mode</code> <code>Union[int, None]</code> <p>Switch to configure the approach to light penetration. Default is None.</p> <code>Kw</code> <code>Union[float, None]</code> <p>Light extinction coefficient. Default is None</p> <code>Kw_file</code> <code>Union[str, None]</code> <p>Name of file with Kw time-series included. Default is None.</p> <code>n_bands</code> <code>Union[int, None]</code> <p>Number of light bandwidths to simulate. Default is None.</p> <code>light_extc</code> <code>Union[List[float], None]</code> <p>Comma-separated list of light extinction coefficients for each waveband. Default is None.</p> <code>energy_frac</code> <code>Union[List[float], None]</code> <p>Comma-separated list of energy fraction captured by each waveband. Default is None.</p> <code>Benthic_Imin</code> <code>Union[float, None]</code> <p>Critical fraction of incident light reaching the benthos. Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLLight\n&gt;&gt;&gt; light = NMLLight()\n&gt;&gt;&gt; my_light = {\n&gt;&gt;&gt;     'light_mode': 0,\n&gt;&gt;&gt;     'Kw': 0.57,\n&gt;&gt;&gt;     'n_bands': 4,\n&gt;&gt;&gt;     'light_extc': [1.0, 0.5, 2.0, 4.0],\n&gt;&gt;&gt;     'energy_frac': [0.51, 0.45, 0.035, 0.005],\n&gt;&gt;&gt;     'Benthic_Imin': 10\n&gt;&gt;&gt; }\n&gt;&gt;&gt; light.set_attributes(my_light)\n&gt;&gt;&gt; print(light)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLLight.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the <code>NMLLight</code> object.</p> <p>Returns a <code>.nml</code> formatted string of the <code>NMLLight</code> attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the <code>NMLLight</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLLight\n&gt;&gt;&gt; light = NMLLight()\n&gt;&gt;&gt; my_light = {\n&gt;&gt;&gt;     'light_mode': 0,\n&gt;&gt;&gt;     'Kw': 0.57,\n&gt;&gt;&gt;     'n_bands': 4,\n&gt;&gt;&gt;     'light_extc': [1.0, 0.5, 2.0, 4.0],\n&gt;&gt;&gt;     'energy_frac': [0.51, 0.45, 0.035, 0.005],\n&gt;&gt;&gt;     'Benthic_Imin': 10\n&gt;&gt;&gt; }\n&gt;&gt;&gt; light.set_attributes(my_light)\n&gt;&gt;&gt; print(light)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLMeteorology","title":"<code>NMLMeteorology</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Define the <code>&amp;meteorology</code> block of a GLM model.</p> <p>Used to configure the meteorological dynamics of the model, e.g., rainfall, air temperature, and incoming radiation. Attributes are set using  the <code>set_attributes()</code> method and returned as a formatted string using the <code>__str__()</code> method.</p> <p>Attributes:</p> Name Type Description <code>met_sw</code> <code>Union[bool, None]</code> <p>Switch to enable the surface heating module. Default is None.</p> <code>meteo_fl</code> <code>Union[str, None]</code> <p>Filename of the meterological file. Default is None.</p> <code>subdaily</code> <code>Union[bool, None]</code> <p>Switch to indicate the meteorological data is provided with sub-daily resolution, at an interval equivalent to \u0394t. Default is None.</p> <code>time_fmt</code> <code>Union[str, None]</code> <p>Time format of the 1st column in the inflow_fl. For example, 'YYYY-MM-DD hhss'. Default is None.</p> <code>rad_mode</code> <code>Union[int, None]</code> <p>Switch to configure which incoming radiation option to use. Default is None.</p> <code>albedo_mode</code> <code>Union[int, None]</code> <p>Switch to configure which albedo calculation option is used. Default is None.</p> <code>sw_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the shortwave radiation data provided in the meteo_fl. Default is None.</p> <code>lw_type</code> <code>Union[str, None]</code> <p>Switch to configure which input approach is being used for longwave/cloud data in the meteo_fl. Default is None.</p> <code>cloud_mode</code> <code>Union[int, None]</code> <p>Switch to configure which atmospheric emmissivity calculation option is used. Default is None.</p> <code>lw_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the longwave (or cloud) data provided in the meteo_fl. Default is None.</p> <code>atm_stab</code> <code>Union[int, None]</code> <p>Switch to configure which approach to atmospheric stability is used. Default is None.</p> <code>rh_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the relative humidity data provided in the meteo_fl. Default is None.</p> <code>at_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the air temperature data provided in the meteo_fl. Default is None.</p> <code>ce</code> <code>Union[float, None]</code> <p>Bulk aerodynamic transfer coefficient for latent heat flux. Default is None.</p> <code>ch</code> <code>Union[float, None]</code> <p>Bulk aerodynamic transfer coefficient for sensible heat flux. Default is None.</p> <code>rain_sw</code> <code>Union[bool, None]</code> <p>Switch to configure rainfall input concentrations. Default is None.</p> <code>rain_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the rainfall data provided in the meteo_fl. Default is None.</p> <code>catchrain</code> <code>Union[bool, None]</code> <p>Switch that configures runoff from exposed banks of lake area. Default is None.</p> <code>rain_threshold</code> <code>Union[float, None]</code> <p>Daily rainfall amount (m) required before runoff from exposed banks occurs. Default is None.</p> <code>runoff_coef</code> <code>Union[float, None]</code> <p>Conversion fraction of infiltration excess rainfall to runoff in exposed lake banks. Default is None.</p> <code>cd</code> <code>Union[float, None]</code> <p>Bulk aerodynamic transfer coefficient for momentum. Default is None.</p> <code>wind_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the windspeed data provided in the meteo_fl. Default is None.</p> <code>fetch_mode</code> <code>Union[int, None]</code> <p>Switch to configure which wind-sheltering/fetch option to use. Default is None.</p> <code>num_dir</code> <code>Union[int, None]</code> <p>Number of wind direction reference points being read in. Default is None.</p> <code>wind_dir</code> <code>Union[float, None]</code> <p>Wind direction reference points (degrees) being read in. Default is None.</p> <code>fetch_scale</code> <code>Union[float, None]</code> <p>Direction specific wind-sheltering scaling factors. Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLMeteorology\n&gt;&gt;&gt; meteorology = NMLMeteorology()\n&gt;&gt;&gt; my_meteorology = {\n&gt;&gt;&gt;     'met_sw': True,\n&gt;&gt;&gt;     'lw_type': 'LW_IN',\n&gt;&gt;&gt;     'rain_sw': False,\n&gt;&gt;&gt;     'atm_stab': 0,\n&gt;&gt;&gt;     'fetch_mode': 0,\n&gt;&gt;&gt;     'rad_mode': 1,\n&gt;&gt;&gt;     'albedo_mode': 1,\n&gt;&gt;&gt;     'cloud_mode': 4,\n&gt;&gt;&gt;     'subdaily': True,\n&gt;&gt;&gt;     'meteo_fl': 'bcs/met_hourly.csv',\n&gt;&gt;&gt;     'wind_factor': 0.9,\n&gt;&gt;&gt;     'ce': 0.0013,\n&gt;&gt;&gt;     'ch': 0.0013,\n&gt;&gt;&gt;     'cd': 0.0013,\n&gt;&gt;&gt;     'catchrain': True,\n&gt;&gt;&gt;     'rain_threshold': 0.001,\n&gt;&gt;&gt;     'runoff_coef': 0.0,\n&gt;&gt;&gt; }\n&gt;&gt;&gt; meteorology.set_attributes(my_meteorology)\n&gt;&gt;&gt; print(meteorology)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLMeteorology.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the <code>NMLMeteorology</code> object.</p> <p>Returns a <code>.nml</code> formatted string of the <code>NMLMeteorology</code> attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the <code>NMLMeteorology</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLMeteorology\n&gt;&gt;&gt; meteorology = NMLMeteorology()\n&gt;&gt;&gt; my_meteorology = {\n&gt;&gt;&gt;     'met_sw': True,\n&gt;&gt;&gt;     'lw_type': 'LW_IN',\n&gt;&gt;&gt;     'rain_sw': False,\n&gt;&gt;&gt;     'atm_stab': 0,\n&gt;&gt;&gt;     'fetch_mode': 0,\n&gt;&gt;&gt;     'rad_mode': 1,\n&gt;&gt;&gt;     'albedo_mode': 1,\n&gt;&gt;&gt;     'cloud_mode': 4,\n&gt;&gt;&gt;     'subdaily': True,\n&gt;&gt;&gt;     'meteo_fl': 'bcs/met_hourly.csv',\n&gt;&gt;&gt;     'wind_factor': 0.9,\n&gt;&gt;&gt;     'ce': 0.0013,\n&gt;&gt;&gt;     'ch': 0.0013,\n&gt;&gt;&gt;     'cd': 0.0013,\n&gt;&gt;&gt;     'catchrain': True,\n&gt;&gt;&gt;     'rain_threshold': 0.001,\n&gt;&gt;&gt;     'runoff_coef': 0.0,\n&gt;&gt;&gt; }\n&gt;&gt;&gt; meteorology.set_attributes(my_meteorology)\n&gt;&gt;&gt; print(meteorology)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLMixing","title":"<code>NMLMixing</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Define the <code>&amp;mixing</code> block of a GLM model.</p> <p>Used to configure the mixing processes within the modelled water body. Attributes are set using the <code>set_attributes()</code> method and returned as a formatted string using the <code>__str__()</code> method.</p> <p>Attributes:</p> Name Type Description <code>surface_mixing</code> <code>Union[int, None]</code> <p>Switch to select the options of the surface mixing model. Default is None.</p> <code>coef_mix_conv</code> <code>Union[float, None]</code> <p>Mixing efficiency - convective overturn. Default is None.</p> <code>coef_wind_stir</code> <code>Union[float, None]</code> <p>Mixing efficiency - wind stirring. Default is None.</p> <code>coef_mix_shear</code> <code>Union[float, None]</code> <p>Mixing efficiency - shear production. Default is None.</p> <code>coef_mix_turb</code> <code>Union[float, None]</code> <p>Mixing efficiency - unsteady turbulence effects. Default is None.</p> <code>coef_mix_KH</code> <code>Union[float, None]</code> <p>Mixing efficiency - Kelvin-Helmholtz billowing. Default is None.</p> <code>deep_mixing</code> <code>Union[int, None]</code> <p>Switch to select the options of the deep (hypolimnetic) mixing model (0 = no deep mixing, 1 = constant diffusivity, 2 = weinstock model). Default is None.</p> <code>coef_mix_hyp</code> <code>Union[float, None]</code> <p>Mixing efficiency - hypolimnetic turbulence. Default is None.</p> <code>diff</code> <code>Union[float, None]</code> <p>Background (molecular) diffusivity in the hypolimnion. Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLMixing\n&gt;&gt;&gt; mixing = NMLMixing()\n&gt;&gt;&gt; my_mixing = {\n&gt;&gt;&gt;     \"surface_mixing\": 1,\n&gt;&gt;&gt;     \"coef_mix_conv\": 0.125,\n&gt;&gt;&gt;     \"coef_wind_stir\": 0.23,\n&gt;&gt;&gt;     \"coef_mix_shear\": 0.2,\n&gt;&gt;&gt;     \"coef_mix_turb\": 0.51,\n&gt;&gt;&gt;     \"coef_mix_KH\": 0.3,\n&gt;&gt;&gt;     \"deep_mixing\": 0.2,\n&gt;&gt;&gt;     \"coef_mix_hyp\": 0.5,\n&gt;&gt;&gt;     \"diff\": 0.0,\n&gt;&gt;&gt; }\n&gt;&gt;&gt; mixing.set_attributes(my_mixing)\n&gt;&gt;&gt; print(mixing)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLMixing.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the <code>NMLMixing</code> object.</p> <p>Returns a <code>.nml</code> formatted string of the <code>NMLMixing</code> attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the <code>NMLMixing</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLMixing\n&gt;&gt;&gt; mixing = NMLMixing()\n&gt;&gt;&gt; my_mixing = {\n&gt;&gt;&gt;     \"surface_mixing\": 1,\n&gt;&gt;&gt;     \"coef_mix_conv\": 0.125,\n&gt;&gt;&gt;     \"coef_wind_stir\": 0.23,\n&gt;&gt;&gt;     \"coef_mix_shear\": 0.2,\n&gt;&gt;&gt;     \"coef_mix_turb\": 0.51,\n&gt;&gt;&gt;     \"coef_mix_KH\": 0.3,\n&gt;&gt;&gt;     \"deep_mixing\": 0.2,\n&gt;&gt;&gt;     \"coef_mix_hyp\": 0.5,\n&gt;&gt;&gt;     \"diff\": 0.0,\n&gt;&gt;&gt; }\n&gt;&gt;&gt; mixing.set_attributes(my_mixing)\n&gt;&gt;&gt; print(mixing)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLMorphometry","title":"<code>NMLMorphometry</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Define the <code>&amp;morphometry</code> block of a GLM model.</p> <p>Used to configure the morphological parameters of the modelled water body. Attributes are set using the <code>set_attributes()</code> method and returned as a formatted string using the <code>__str__()</code> method.</p> <p>Attributes:</p> Name Type Description <code>lake_name</code> <code>Union[str, None]</code> <p>Site name. Default is None.</p> <code>latitude</code> <code>float</code> <p>Latitude, positive North. Default is 0.0.</p> <code>longitude</code> <code>float</code> <p>Longitude, positive East. Default is 0.0.</p> <code>base_elev</code> <code>Union[float, None]</code> <p>Elevation of the bottom-most point of the lake (m above datum). Default is None.</p> <code>crest_elev</code> <code>Union[float, None]</code> <p>Elevation of a weir crest, where overflow begins. Default is None.</p> <code>bsn_len</code> <code>Union[float, None]</code> <p>Length of the lake basin, at crest height (m). Default is None.</p> <code>bsn_wid</code> <code>Union[float, None]</code> <p>Width of the lake basin, at crest height (m). Default is None.</p> <code>bsn_vals</code> <code>Union[float, None]</code> <p>Number of points being provided to described the hyposgraphic details. Default is None.</p> <code>H</code> <code>Union[List[float], None]</code> <p>Comma-separated list of lake elevations (m above datum). Default is None.</p> <code>A</code> <code>Union[List[float], None]</code> <p>Comma-separated list of lake areas (m^2). Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLMorphometry\n&gt;&gt;&gt; morphometry = NMLMorphometry()\n&gt;&gt;&gt; my_morphometry = {\n...     \"lake_name\": \"Example Lake\",\n...     \"latitude\": 32,\n...     \"longitude\": 35,\n...     \"base_elev\": -252.9,\n...     \"crest_elev\": -203.9,\n...     \"bsn_len\": 21000,\n...     \"bsn_wid\": 13000,\n...     \"bsn_vals\": 45,\n...     \"H\": [\n...         -252.9, -251.9, -250.9, -249.9, -248.9, -247.9, -246.9,\n...         -245.9, -244.9, -243.9, -242.9, -241.9, -240.9, -239.9,\n...         -238.9, -237.9, -236.9, -235.9, -234.9, -233.9, -232.9,\n...         -231.9, -230.9, -229.9, -228.9, -227.9, -226.9, -225.9,\n...         -224.9, -223.9, -222.9, -221.9, -220.9, -219.9, -218.9,\n...         -217.9, -216.9, -215.9, -214.9, -213.9, -212.9, -211.9,\n...         -208.9, -207.9,  -203.9\n...         ],\n...     \"A\": [\n...         0, 9250000, 15200000, 17875000, 21975000, 26625000,\n...         31700000, 33950000, 38250000, 41100000, 46800000,\n...         51675000, 55725000, 60200000, 64675000, 69600000, 74475000,\n...         79850000, 85400000, 90975000, 96400000, 102000000,\n...         107000000, 113000000, 118000000, 123000000, 128000000,\n...         132000000, 136000000, 139000000, 143000000, 146000000,\n...         148000000, 150000000, 151000000, 153000000, 155000000,\n...         157000000, 158000000, 160000000, 161000000, 162000000,\n...         167000000, 170000000, 173000000\n...         ]\n... }\n&gt;&gt;&gt; morphometry.set_attributes(my_morphometry)\n&gt;&gt;&gt; print(morphometry)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLMorphometry.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the <code>NMLMorphometry</code> object.</p> <p>Returns a <code>.nml</code> formatted string of the <code>NMLMorphometry</code> attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the <code>NMLMorphometry</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLMorphometry\n&gt;&gt;&gt; morphometry = NMLMorphometry()\n&gt;&gt;&gt; my_morphometry = {\n...     \"lake_name\": \"Example Lake\",\n...     \"latitude\": 32,\n...     \"longitude\": 35,\n...     \"base_elev\": -252.9,\n...     \"crest_elev\": -203.9,\n...     \"bsn_len\": 21000,\n...     \"bsn_wid\": 13000,\n...     \"bsn_vals\": 45,\n...     \"H\": [\n...         -252.9, -251.9, -250.9, -249.9, -248.9, -247.9, -246.9,\n...         -245.9, -244.9, -243.9, -242.9, -241.9, -240.9, -239.9,\n...         -238.9, -237.9, -236.9, -235.9, -234.9, -233.9, -232.9,\n...         -231.9, -230.9, -229.9, -228.9, -227.9, -226.9, -225.9,\n...         -224.9, -223.9, -222.9, -221.9, -220.9, -219.9, -218.9,\n...         -217.9, -216.9, -215.9, -214.9, -213.9, -212.9, -211.9,\n...         -208.9, -207.9,  -203.9\n...         ],\n...     \"A\": [\n...         0, 9250000, 15200000, 17875000, 21975000, 26625000,\n...         31700000, 33950000, 38250000, 41100000, 46800000,\n...         51675000, 55725000, 60200000, 64675000, 69600000, 74475000,\n...         79850000, 85400000, 90975000, 96400000, 102000000,\n...         107000000, 113000000, 118000000, 123000000, 128000000,\n...         132000000, 136000000, 139000000, 143000000, 146000000,\n...         148000000, 150000000, 151000000, 153000000, 155000000,\n...         157000000, 158000000, 160000000, 161000000, 162000000,\n...         167000000, 170000000, 173000000\n...         ]\n... }\n&gt;&gt;&gt; morphometry.set_attributes(my_morphometry)\n&gt;&gt;&gt; print(morphometry)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLOutflows","title":"<code>NMLOutflows</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Define the <code>&amp;outflow</code> block of a GLM model.</p> <p>Used to configure the number/type of water outflows. Attributes are set using the <code>set_attributes()</code> method and returned as a formatted string using the <code>__str__()</code> method.</p> <p>Attributes:</p> Name Type Description <code>num_outlet</code> <code>Union[int, None]</code> <p>Number of outflows (including withdrawals, outlets or offtakes) to be included in this simulation. Default is None.</p> <code>outflow_fl</code> <code>Union[str, None]</code> <p>Filename of the file containing the outflow time-series. Default is None.</p> <code>time_fmt</code> <code>Union[str, None]</code> <p>Time format of the 1st column in the outflow_fl. Default is None.</p> <code>outflow_factor</code> <code>Union[float, None]</code> <p>Scaling factor used as a multiplier for outflows. Default is None.</p> <code>outflow_thick_limit</code> <code>Union[List[float], None]</code> <p>Maximum vertical limit of withdrawal entrainment. Default is None.</p> <code>single_layer_draw</code> <code>Union[List[bool], None]</code> <p>Switch to only limit withdrawal entrainment and force outflows from layer at the outlet elevation height. Default is None.</p> <code>flt_off_sw</code> <code>Union[List[bool], None]</code> <p>Switch to indicate if the outflows are floating offtakes (taking water from near the surface). Default is None.</p> <code>outlet_type</code> <code>Union[List[int], None]</code> <p>Switch to configure approach of each withdrawal. Default is None.</p> <code>outl_elvs</code> <code>Union[List[float], None]</code> <p>Outlet elevations (m). Default is [0].</p> <code>bsn_len_outl</code> <code>Union[List[float], None]</code> <p>Basin length at the outlet height(s) (m). Default is None.</p> <code>bsn_wid_outl</code> <code>Union[List[float], None]</code> <p>Basin width at the outlet heights (m). Default is None.</p> <code>seepage</code> <code>Union[bool, None]</code> <p>Switch to enable the seepage of water from the lake bottom. Default is None.</p> <code>seepage_rate</code> <code>Union[float, None]</code> <p>Seepage rate of water, or, soil hydraulic conductivity. Default is None.</p> <code>crest_width</code> <code>Union[float, None]</code> <p>Width of weir (at crest height) where lake overflows (m). Default is None.</p> <code>crest_factor</code> <code>Union[float, None]</code> <p>Drag coefficient associated with the weir crest, used to compute the overflow discharge rate. Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLOutflows\n&gt;&gt;&gt; outflows = NMLOutflows()\n&gt;&gt;&gt; my_outflows = {\n&gt;&gt;&gt;     'num_outlet': 1,\n&gt;&gt;&gt;     'flt_off_sw': [False],\n&gt;&gt;&gt;     'outlet_type': 1,\n&gt;&gt;&gt;     'outl_elvs': [-215.5],\n&gt;&gt;&gt;     'bsn_len_outl': [18000],\n&gt;&gt;&gt;     'bsn_wid_outl': [11000],\n&gt;&gt;&gt;     'outflow_fl': 'bcs/outflow.csv',\n&gt;&gt;&gt;     'outflow_factor': [1.0],\n&gt;&gt;&gt;     'seepage': True,\n&gt;&gt;&gt;     'seepage_rate': 0.01\n&gt;&gt;&gt; }\n&gt;&gt;&gt; outflows.set_attributes(my_outflows)\n&gt;&gt;&gt; print(outflows)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLOutflows.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the <code>NMLOutflows</code> object.</p> <p>Returns a <code>.nml</code> formatted string of the <code>NMLOutflows</code> attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the <code>NMLOutflows</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLOutflows\n&gt;&gt;&gt; outflows = NMLOutflows()\n&gt;&gt;&gt; my_outflows = {\n&gt;&gt;&gt;     'num_outlet': 1,\n&gt;&gt;&gt;     'flt_off_sw': [False],\n&gt;&gt;&gt;     'outlet_type': 1,\n&gt;&gt;&gt;     'outl_elvs': [-215.5],\n&gt;&gt;&gt;     'bsn_len_outl': [18000],\n&gt;&gt;&gt;     'bsn_wid_outl': [11000],\n&gt;&gt;&gt;     'outflow_fl': 'bcs/outflow.csv',\n&gt;&gt;&gt;     'outflow_factor': [1.0],\n&gt;&gt;&gt;     'seepage': True,\n&gt;&gt;&gt;     'seepage_rate': 0.01\n&gt;&gt;&gt; }\n&gt;&gt;&gt; outflows.set_attributes(my_outflows)\n&gt;&gt;&gt; print(outflows)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLOutput","title":"<code>NMLOutput</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Define the <code>&amp;output</code> block of a GLM model.</p> <p>Used to configure how GLM saves the model outputs to file.  Attributes are set using the <code>set_attributes()</code> method and returned as a formatted string using the <code>__str__()</code> method.</p> <p>Attributes:</p> Name Type Description <code>out_dir</code> <code>Union[str, None]</code> <p>Directory to write the output files. Default is None.</p> <code>out_fn</code> <code>Union[str, None]</code> <p>Filename of the main NetCDF output file. Default is None.</p> <code>nsave</code> <code>Union[int, None]</code> <p>Frequency to write to the NetCDF and CSV point files. Default is None.</p> <code>csv_lake_fname</code> <code>Union[str, None]</code> <p>Filename for the daily summary file. Default is None</p> <code>csv_point_nlevs</code> <code>Union[float, None]</code> <p>Number of specific level/depth csv files to be created. Default is None.</p> <code>csv_point_fname</code> <code>Union[str, None]</code> <p>Name to be appended to specified depth CSV files. Default is None.</p> <code>csv_point_frombot</code> <code>Union[List[float], None]</code> <p>Comma separated list identify whether each output point listed in csv_point_at is relative to the bottom (ie heights) or the surface (ie depths). Default is None.</p> <code>csv_point_at</code> <code>Union[List[float], None]</code> <p>Height or Depth of points to output at (comma separated list). Default is None.</p> <code>csv_point_nvars</code> <code>Union[int, None]</code> <p>Number of variables to output into the csv files. Default is None.</p> <code>csv_point_vars</code> <code>Union[List[str], None]</code> <p>Comma separated list of variable names. Default is None.</p> <code>csv_outlet_allinone</code> <code>bool</code> <p>Switch to create an optional outlet file combining all outlets. Default is False.</p> <code>csv_outlet_fname</code> <code>Union[str, None]</code> <p>Name to be appended to each of the outlet CSV files. Default is None.</p> <code>csv_outlet_nvars</code> <code>Union[int, None]</code> <p>Number of variables to be written into the outlet file(s). Default is None.</p> <code>csv_outlet_vars</code> <code>Union[str, None]</code> <p>Comma separated list of variable names to be included in the output file(s). Default is None.</p> <code>csv_ovrflw_fname</code> <code>Union[str, None]</code> <p>Filename to be used for recording the overflow details. Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLOutput\n&gt;&gt;&gt; output = NMLOutput()\n&gt;&gt;&gt; my_output = {\n&gt;&gt;&gt;     'out_dir': 'output',\n&gt;&gt;&gt;     'out_fn': 'output',\n&gt;&gt;&gt;     'nsave': 6,\n&gt;&gt;&gt;     'csv_lake_fname': 'lake',\n&gt;&gt;&gt;     'csv_point_nlevs': 2.0,\n&gt;&gt;&gt;     'csv_point_fname': 'WQ_',\n&gt;&gt;&gt;     'csv_point_at': [5, 30],\n&gt;&gt;&gt;     'csv_point_nvars': 7,\n&gt;&gt;&gt;     'csv_point_vars': ['temp', 'salt', 'OXY_oxy', 'SIL_rsi', 'NIT_amm', 'NIT_nit', 'PHS_frp'],\n&gt;&gt;&gt;     'csv_outlet_allinone': False,\n&gt;&gt;&gt;     'csv_outlet_fname': 'outlet_',\n&gt;&gt;&gt;     'csv_outlet_nvars': 4,\n&gt;&gt;&gt;     'csv_outlet_vars': ['flow', 'temp', 'salt', 'OXY_oxy'],\n&gt;&gt;&gt;     'csv_ovrflw_fname': 'overflow'\n&gt;&gt;&gt; }\n&gt;&gt;&gt; output.set_attributes(my_output)\n&gt;&gt;&gt; print(output)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLOutput.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the <code>NMLOutput</code> object.</p> <p>Returns a <code>.nml</code> formatted string of the <code>NMLOutput</code> attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the <code>NMLOutput</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLOutput\n&gt;&gt;&gt; output = NMLOutput()\n&gt;&gt;&gt; my_output = {\n&gt;&gt;&gt;     'out_dir': 'output',\n&gt;&gt;&gt;     'out_fn': 'output',\n&gt;&gt;&gt;     'nsave': 6,\n&gt;&gt;&gt;     'csv_lake_fname': 'lake',\n&gt;&gt;&gt;     'csv_point_nlevs': 2.0,\n&gt;&gt;&gt;     'csv_point_fname': 'WQ_',\n&gt;&gt;&gt;     'csv_point_at': [5, 30],\n&gt;&gt;&gt;     'csv_point_nvars': 7,\n&gt;&gt;&gt;     'csv_point_vars': ['temp', 'salt', 'OXY_oxy', 'SIL_rsi', 'NIT_amm', 'NIT_nit', 'PHS_frp'],\n&gt;&gt;&gt;     'csv_outlet_allinone': False,\n&gt;&gt;&gt;     'csv_outlet_fname': 'outlet_',\n&gt;&gt;&gt;     'csv_outlet_nvars': 4,\n&gt;&gt;&gt;     'csv_outlet_vars': ['flow', 'temp', 'salt', 'OXY_oxy'],\n&gt;&gt;&gt;     'csv_ovrflw_fname': 'overflow'\n&gt;&gt;&gt; }\n&gt;&gt;&gt; output.set_attributes(my_output)\n&gt;&gt;&gt; print(output)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLSediment","title":"<code>NMLSediment</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Define the <code>&amp;sediment</code> block of a GLM model.</p> <p>Used to configure the thermal properties of the soil-sediment. Attributes are set using the <code>set_attributes()</code> method and returned as a formatted string using the <code>__str__()</code> method.</p> <p>Attributes:</p> Name Type Description <code>sed_heat_Ksoil</code> <code>Union[float, None]</code> <p>Heat conductivity of soil/sediment. Default is None.</p> <code>sed_temp_depth</code> <code>Union[float, None]</code> <p>Depth of soil/sediment layer below the lake bottom, used for heat flux calculation. Default is None.</p> <code>sed_temp_mean</code> <code>Union[List[float], None]</code> <p>Annual mean sediment temperature. Default is None.</p> <code>sed_temp_amplitude</code> <code>Union[List[float], None]</code> <p>Amplitude of temperature variation experienced in the sediment over one year. Default is None.</p> <code>sed_temp_peak_doy</code> <code>Union[List[int], None]</code> <p>Day of the year where the sediment temperature peaks. Default is None.</p> <code>benthic_mode</code> <code>Union[int, None]</code> <p>Switch to configure which mode of benthic interaction to apply. Default is None.</p> <code>n_zones</code> <code>Union[int, None]</code> <p>Number of sediment zones to simulate. Default is None.</p> <code>zone_heights</code> <code>Union[List[float], None]</code> <p>Upper height of zone boundary. Default is None.</p> <code>sed_reflectivity</code> <code>Union[List[float], None]</code> <p>Sediment reflectivity. Default is None.</p> <code>sed_roughness</code> <code>Union[List[float], None]</code> <p>Sediment roughness. Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLSediment\n&gt;&gt;&gt; sediment = NMLSediment()\n&gt;&gt;&gt; my_sediment = {\n&gt;&gt;&gt;     'sed_heat_Ksoil': 0.0,\n&gt;&gt;&gt;     'sed_temp_depth': 0.2,\n&gt;&gt;&gt;     'sed_temp_mean': [5,10,20],\n&gt;&gt;&gt;     'sed_temp_amplitude': [6,8,10],\n&gt;&gt;&gt;     'sed_temp_peak_doy': [80, 70, 60],\n&gt;&gt;&gt;     'benthic_mode': 1,\n&gt;&gt;&gt;     'n_zones': 3,\n&gt;&gt;&gt;     'zone_heights': [10., 20., 50.],\n&gt;&gt;&gt;     'sed_reflectivity': [0.1, 0.01, 0.01],\n&gt;&gt;&gt;     'sed_roughness': [0.1, 0.01, 0.01]\n&gt;&gt;&gt; }\n&gt;&gt;&gt; sediment.set_attributes(my_sediment)\n&gt;&gt;&gt; print(sediment)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLSediment.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the <code>NMLSediment</code> object.</p> <p>Returns a <code>.nml</code> formatted string of the NMLSediment attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the <code>NMLSediment</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLSediment\n&gt;&gt;&gt; sediment = NMLSediment()\n&gt;&gt;&gt; my_sediment = {\n&gt;&gt;&gt;     'sed_heat_Ksoil': 0.0,\n&gt;&gt;&gt;     'sed_temp_depth': 0.2,\n&gt;&gt;&gt;     'sed_temp_mean': [5,10,20],\n&gt;&gt;&gt;     'sed_temp_amplitude': [6,8,10],\n&gt;&gt;&gt;     'sed_temp_peak_doy': [80, 70, 60],\n&gt;&gt;&gt;     'benthic_mode': 1,\n&gt;&gt;&gt;     'n_zones': 3,\n&gt;&gt;&gt;     'zone_heights': [10., 20., 50.],\n&gt;&gt;&gt;     'sed_reflectivity': [0.1, 0.01, 0.01],\n&gt;&gt;&gt;     'sed_roughness': [0.1, 0.01, 0.01]\n&gt;&gt;&gt; }\n&gt;&gt;&gt; sediment.set_attributes(my_sediment)\n&gt;&gt;&gt; print(sediment)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLSetup","title":"<code>NMLSetup</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Define the <code>&amp;glm_setup</code> block of a GLM model.</p> <p>The <code>&amp;glm_setup</code> component is used to define properties of the vertical series of layers used by GLM to model a water body. Attributes are set using the <code>set_attributes()</code> method and returned as a formatted string using the <code>__str__()</code> method.</p> <p>Attributes:</p> Name Type Description <code>sim_name</code> <code>Union[str, None]</code> <p>Title of simulation. Default is None.</p> <code>max_layers</code> <code>Union[int, None]</code> <p>Maximum number of layers. Default is None.</p> <code>min_layer_vol</code> <code>Union[float, None]</code> <p>Minimum layer volume. Default is None.</p> <code>min_layer_thick</code> <code>Union[float, None]</code> <p>Minimum thickness of a layer (m). Default is None.</p> <code>max_layer_thick</code> <code>Union[float, None]</code> <p>Maximum thickness of a layer (m). Default is None.</p> <code>density_model</code> <code>Union[int, None]</code> <p>Switch to set the density equation. Default is None.</p> <code>non_avg</code> <code>Union[bool, None]</code> <p>Switch to configure flow boundary condition temporal interpolation. Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLSetup\n&gt;&gt;&gt; setup = NMLSetup()\n&gt;&gt;&gt; my_setup = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_vol\": 0.15,\n...     \"min_layer_thick\": 1.50,\n...     \"max_layer_thick\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": True\n... }\n&gt;&gt;&gt; setup.set_attributes(my_setup)\n&gt;&gt;&gt; print(setup)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLSetup.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the <code>NMLSetup</code> object.</p> <p>Returns a <code>.nml</code> formatted string of the <code>NMLSetup</code> attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the <code>NMLSetup</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLSetup\n&gt;&gt;&gt; setup = NMLSetup()\n&gt;&gt;&gt; my_setup = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_vol\": 0.15,\n...     \"min_layer_thick\": 1.50,\n...     \"max_layer_thick\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": True\n... }\n&gt;&gt;&gt; setup.set_attributes(my_setup)\n&gt;&gt;&gt; print(setup)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLSnowIce","title":"<code>NMLSnowIce</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Define the <code>&amp;snowice</code> block of a GLM model.</p> <p>Used to configure formation of snow and ice cover on the simulated water body. Attributes are set using the <code>set_attributes()</code> method and returned as a formatted string using the <code>__str__()</code> method.</p> <p>Attributes:</p> Name Type Description <code>snow_albedo_factor</code> <code>Union[float, None]</code> <p>Scaling factor used to as a multiplier to scale the snow/ice albedo estimate. Default is None.</p> <code>snow_rho_max</code> <code>Union[float, None]</code> <p>Minimum snow density allowable. Default is None.</p> <code>snow_rho_min</code> <code>Union[float, None]</code> <p>Maximum snow density allowable. Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLSnowIce\n&gt;&gt;&gt; snow_ice = NMLSnowIce()\n&gt;&gt;&gt; my_snow_ice = {\n&gt;&gt;&gt;        'snow_albedo_factor': 0.0,\n&gt;&gt;&gt;        'snow_rho_min': 50,\n&gt;&gt;&gt;        'snow_rho_max': 300\n&gt;&gt;&gt;    }\n&gt;&gt;&gt; snow_ice.set_attributes(my_snow_ice)\n&gt;&gt;&gt; print(snow_ice)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLSnowIce.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the <code>NMLSnowIce</code> object.</p> <p>Returns a <code>.nml</code> formatted string of the <code>NMLSnowIce</code> attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the <code>NMLSnowIce</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLSnowIce\n&gt;&gt;&gt; snow_ice = NMLSnowIce()\n&gt;&gt;&gt; my_snow_ice = {\n&gt;&gt;&gt;        'snow_albedo_factor': 0.0,\n&gt;&gt;&gt;        'snow_rho_min': 50,\n&gt;&gt;&gt;        'snow_rho_max': 300\n&gt;&gt;&gt;    }\n&gt;&gt;&gt; snow_ice.set_attributes(my_snow_ice)\n&gt;&gt;&gt; print(snow_ice)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLTime","title":"<code>NMLTime</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Define the <code>&amp;time</code> block of a GLM model.</p> <p>Used to configure the temporal parameters of the model, e.g., simulation period, time step, and time zone. Attributes are set using the <code>set_attributes()</code> method and returned as a formatted string using the <code>__str__()</code> method.</p> <p>Attributes:</p> Name Type Description <code>timefmt</code> <code>Union[int, None]</code> <p>Time configuration switch. Default is None.</p> <code>start</code> <code>Union[str, None]</code> <p>Start time/date of simulation in format 'yyyy-mm-dd hhss'. Default is None.</p> <code>stop</code> <code>Union[str, None]</code> <p>End time/date of simulation in format 'yyyy-mm-dd hhss'. Default is None.</p> <code>dt</code> <code>Union[float, None]</code> <p>Time step (seconds). Default is None</p> <code>num_days</code> <code>Union[int, None]</code> <p>Number of days to simulate. Default is None.</p> <code>timezone</code> <code>Union[float, None]</code> <p>UTC time zone. Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLSetup\n&gt;&gt;&gt; time = NMLTime()\n&gt;&gt;&gt; my_time = {\n&gt;&gt;&gt;     \"timefmt\": 3,\n&gt;&gt;&gt;     \"start\": '1997-01-01 00:00:00',\n&gt;&gt;&gt;     \"stop\": '1999-01-01 00:00:00',\n&gt;&gt;&gt;     \"dt\": 3600.0,\n&gt;&gt;&gt;     \"num_days\": 730,\n&gt;&gt;&gt;     \"timezone\": 7.0\n&gt;&gt;&gt; }\n&gt;&gt;&gt; time.set_attributes(my_time)\n&gt;&gt;&gt; print(time)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLTime.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the <code>NMLTime</code> object.</p> <p>Returns a <code>.nml</code> formatted string of the <code>NMLTime</code> attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the <code>NMLTime</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLSetup\n&gt;&gt;&gt; time = NMLTime()\n&gt;&gt;&gt; my_time = {\n&gt;&gt;&gt;     \"timefmt\": 3,\n&gt;&gt;&gt;     \"start\": '1997-01-01 00:00:00',\n&gt;&gt;&gt;     \"stop\": '1999-01-01 00:00:00',\n&gt;&gt;&gt;     \"dt\": 3600.0,\n&gt;&gt;&gt;     \"num_days\": 730,\n&gt;&gt;&gt;     \"timezone\": 7.0\n&gt;&gt;&gt; }\n&gt;&gt;&gt; time.set_attributes(my_time)\n&gt;&gt;&gt; print(time)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLWQSetup","title":"<code>NMLWQSetup</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Define the <code>&amp;wq_setup</code>  block of a GLM simulation configuration.</p> <p>Used to configure the water quality library selection, solution options, and benthic coupling mode. Attributes are set using the <code>set_attributes()</code> method and returned as a formatted string using the <code>__str__()</code> method.</p> <p>Attributes:</p> Name Type Description <code>wq_lib</code> <code>Union[bool, str]</code> <p>Water quality model selection. Default is None.</p> <code>wq_nml_file</code> <code>Union[str, None]</code> <p>Filename of WQ configuration file. Default is None.</p> <code>bioshade_feedback</code> <code>Union[bool, None]</code> <p>Switch to enable Kw to be updated by the WQ model. Default is None.</p> <code>mobility_off</code> <code>Union[bool, None]</code> <p>Switch to enable settling within the WQ model. Default is None.</p> <code>ode_method</code> <code>Union[int, None]</code> <p>Method to use for ODE solution of water quality module. Default is None.</p> <code>split_factor</code> <code>Union[float, None]</code> <p>Factor weighting implicit vs explicit numerical solution of the WQ model. Default is None.</p> <code>repair_state</code> <code>Union[bool, None]</code> <p>Switch to correct negative or out of range WQ variables. Default is None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLWQSetup\n&gt;&gt;&gt; wq_setup = NMLWQSetup()\n&gt;&gt;&gt; my_wq_setup = {\n&gt;&gt;&gt;     'wq_lib': 'aed2',\n&gt;&gt;&gt;     'wq_nml_file': 'aed2/aed2.nml',\n&gt;&gt;&gt;     'ode_method': 1,\n&gt;&gt;&gt;     'split_factor': 1,\n&gt;&gt;&gt;     'bioshade_feedback': True,\n&gt;&gt;&gt;     'repair_state': True,\n&gt;&gt;&gt;     'mobility_off': False\n&gt;&gt;&gt; }\n&gt;&gt;&gt; wq_setup.set_attributes(my_wq_setup)\n&gt;&gt;&gt; print(wq_setup)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLWQSetup.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the <code>NMLWQSetup</code> object.</p> <p>Returns a <code>.nml</code> formatted string of the <code>NMLWQSetup</code> attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the <code>NMLWQSetup</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import NMLWQSetup\n&gt;&gt;&gt; wq_setup = NMLWQSetup()\n&gt;&gt;&gt; my_wq_setup = {\n&gt;&gt;&gt;     'wq_lib': 'aed2',\n&gt;&gt;&gt;     'wq_nml_file': 'aed2/aed2.nml',\n&gt;&gt;&gt;     'ode_method': 1,\n&gt;&gt;&gt;     'split_factor': 1,\n&gt;&gt;&gt;     'bioshade_feedback': True,\n&gt;&gt;&gt;     'repair_state': True,\n&gt;&gt;&gt;     'mobility_off': False\n&gt;&gt;&gt; }\n&gt;&gt;&gt; wq_setup.set_attributes(my_wq_setup)\n&gt;&gt;&gt; print(wq_setup)\n</code></pre>"},{"location":"outflows/","title":"Outflows","text":""},{"location":"outflows/#glmpy.outflows.CustomOutflows","title":"<code>CustomOutflows</code>","text":"<p>Create a simple outflow timeseries for GLM.</p> <p>Generates a outflow timeseries between a given start and end date using a specified base flow (m^3). The timeseries can be updated in two ways: 1. By providing a dictionary with specific dates and their corresponding outflows. 2. By specifying a fixed outflow value between two dates. Once updated, the outflow data can be exported to a CSV file in units of m^3/second.</p> <p>Attributes:</p> Name Type Description <code>start_datetime</code> <code>str</code> <p>Start datetime of the outflow timeseries. Must be in either 'YYYY-MM-DD' or 'YYYY-MM-DD HH:MM:SS' format.</p> <code>end_datetime</code> <code>str</code> <p>End datetime of the outflow timeseries. Must be in either 'YYYY-MM-DD' or 'YYYY-MM-DD HH:MM:SS' format.</p> <code>frequency</code> <code>str</code> <p>Frequency of the outflow timeseries. Must be either 'daily' or 'hourly'. Defaults to 'daily'.</p> <code>base_outflow</code> <code>Union[int, float]</code> <p>Base flow of the outflow timeseries in m^3/day or m^3/hour depending on <code>frequency</code>. Defaults to 0.0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n</code></pre> <p>Initialise a daily outflow timeseries with a base outflow of 0.0 m^3/day:</p> <pre><code>&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01\",\n...     end_datetime=\"2020-01-10\",\n...     frequency=\"daily\",\n...     base_outflow=0.0\n... )\n</code></pre> <p>Update the timeseries with a dictionary of specific dates and their corresponding outflows:</p> <pre><code>&gt;&gt;&gt; outflows_dict = {\n...     \"2020-01-01 00:00:00\": 10,\n...     \"2020-01-02 00:00:00\": 11,\n...     \"2020-01-03 00:00:00\": 12\n... }\n&gt;&gt;&gt; outflows.set_discrete_outflows(outflows_dict)\n</code></pre> <p>Return the outflows timeseries as a pandas DataFrame:</p> <pre><code>&gt;&gt;&gt; outflows.get_outflows()\n</code></pre> <p>Update the timeseries with a fixed outflow between two dates:</p> <pre><code>&gt;&gt;&gt; outflows.set_continuous_outflows(\n...     from_datetime=\"2020-01-05\",\n...     to_datetime = \"2020-01-09\",\n...     continuous_outflow = 9\n... )\n</code></pre> <p>Return the updated timeseries:</p> <pre><code>&gt;&gt;&gt; outflows.get_outflows()\n</code></pre>"},{"location":"outflows/#glmpy.outflows.CustomOutflows.get_outflows","title":"<code>get_outflows()</code>","text":"<p>Get the outflow timeseries.</p> <p>Returns the outflow timeseries as a pandas DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01\",\n...     end_datetime=\"2020-01-10\",\n...     frequency=\"daily\",\n...     base_outflow=0.0\n... )\n&gt;&gt;&gt; outflows.get_outflows()\n</code></pre>"},{"location":"outflows/#glmpy.outflows.CustomOutflows.set_continuous_outflows","title":"<code>set_continuous_outflows(from_datetime, to_datetime, continuous_outflow)</code>","text":"<p>Set the outflow volume between two datetimes.</p> <p>Outflow volumes between two datetimes can be set by providing a start datetime, end datetime and an outflow volume.</p> <p>Parameters:</p> Name Type Description Default <code>from_datetime</code> <code>str</code> <p>Update the outflow timeseries from this datetime. Must be in 'YYYY-MM-DD' or 'YYYY-MM-DD HH:MM:SS' format.</p> required <code>to_datetime</code> <code>str</code> <p>Update the outflow timeseries to this datetime. Must be in  'YYYY-MM-DD' or 'YYYY-MM-DD HH:MM:SS' format.</p> required <code>continuous_outflow</code> <code>float</code> <p>The outflow volume to set between the <code>from_datetime</code> and <code>to_datetime</code> in m^3/day or m^3/hour.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01 00:00:00\",\n...     end_datetime=\"2020-01-01 23:00:00\",\n...     frequency=\"hourly\",\n...     base_outflow=0.0\n... )\n&gt;&gt;&gt; outflows.set_continuous_outflows(\n...     from_datetime=\"2020-01-01 01:00:00\",\n...     to_datetime = \"2020-01-01 10:00:00\",\n...     continuous_outflow = 9\n... )\n&gt;&gt;&gt; outflows.get_outflows()\n</code></pre>"},{"location":"outflows/#glmpy.outflows.CustomOutflows.set_discrete_outflows","title":"<code>set_discrete_outflows(outflows_dict)</code>","text":"<p>Set the outflow volume for specific datetimes.</p> <p>The outflow volume for specific datetimes can be set by providing a dictionary with datetimes as keys and outflow volumes as values. The dictionary keys must be in 'YYYY-MM-DD' or 'YYYY-MM-DD HH:MM:SS. Outflow volumes must be provided in the same units as the base outflow (m^3/day or m^3/hour).</p> <p>Parameters:</p> Name Type Description Default <code>outflows_dict</code> <code>Dict[str, Union[int, float]]</code> <p>Dictionary with datetimes as keys and outflow volumes as values.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01 00:00:00\",\n...     end_datetime=\"2020-01-01 23:00:00\",\n...     frequency=\"hourly\",\n...     base_outflow=0.0\n... )\n&gt;&gt;&gt; outflows_dict = {\n...     \"2020-01-01 01:00:00\": 10,\n...     \"2020-01-01 02:00:00\": 11,\n...     \"2020-01-01 03:00:00\": 12\n... }\n&gt;&gt;&gt; outflows.set_discrete_outflows(outflows_dict)\n&gt;&gt;&gt; outflows.get_outflows()\n</code></pre>"},{"location":"outflows/#glmpy.outflows.CustomOutflows.write_outflows","title":"<code>write_outflows(file_path)</code>","text":"<p>Write the outflow timeseries to a csv file.</p> <p>The outflow timeseries can be written to a csv file by providing a path to the csv file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the csv file to which the outflow timeseries will be written.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01\",\n...     end_datetime=\"2020-01-10\",\n...     frequency=\"daily\",\n...     base_outflow=10\n... )\n&gt;&gt;&gt; outflows.write_outflows(file_path=\"outflows.csv\")\n</code></pre>"},{"location":"simulation/","title":"Simulations","text":""},{"location":"simulation/#glmpy.simulation.GlmPostProcessor","title":"<code>GlmPostProcessor</code>","text":"<p>Class to process outputs of GLM simulation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; import shutil\n</code></pre> <pre><code>&gt;&gt;&gt; from glmpy import simulation as sim\n</code></pre> <pre><code>&gt;&gt;&gt; files = {\n&gt;&gt;&gt;    \"glm3.nml\": os.path.join(os.getcwd(), \"glm3.nml\"),\n&gt;&gt;&gt;    \"met.csv\": os.path.join(os.getcwd(), \"met.csv\"),\n&gt;&gt;&gt; }\n</code></pre> <pre><code>&gt;&gt;&gt; # running local instance of GLM\n&gt;&gt;&gt; glm_run = sim.GlmSim(files, False, \"/inputs\")\n&gt;&gt;&gt; inputs_dir = glm_run.prepare_inputs()\n</code></pre> <pre><code>&gt;&gt;&gt; glm_run.glm_run(inputs_dir, \"/glm/glm\")\n</code></pre> <pre><code>&gt;&gt;&gt; outputs_dir = os.path.join(inputs_dir, \"output\")\n</code></pre> <pre><code>&gt;&gt;&gt; # initialise GlmPostProcessor object\n&gt;&gt;&gt; glm_process = sim.GlmPostProcessor(outputs_dir)\n</code></pre> <pre><code>&gt;&gt;&gt; # create zipfile of GLM outputs\n&gt;&gt;&gt; # csv file and netcdf\n&gt;&gt;&gt; # returns path to zipfile of outputs\n&gt;&gt;&gt; files_zip_path = glm_process.zip_outputs()\n</code></pre> <pre><code>&gt;&gt;&gt; # create zipfile of csv GLM outputs\n&gt;&gt;&gt; files_zip_csv_path = glm_process.zip_csvs()\n</code></pre> <pre><code>&gt;&gt;&gt; # create zipfile of JSON GLM outputs\n&gt;&gt;&gt; files_zip_json_path = glm_process.zip_json()\n</code></pre>"},{"location":"simulation/#glmpy.simulation.GlmPostProcessor.__init__","title":"<code>__init__(outputs_path)</code>","text":"<p>Class to process outputs of GLM simulation.</p> <p>Attributes:</p> Name Type Description <code>outputs_path</code> <code>str</code> <p>Path to directory where GLM outputs have been written.</p>"},{"location":"simulation/#glmpy.simulation.GlmPostProcessor.csv_to_json","title":"<code>csv_to_json(csv_lake_fname, variables)</code>","text":"<p>Converts outputs of GLM simulation in csv format to JSON.</p> <p>Can be used to as step before saving GLM results to JSON files or to generate JSON formatted data that can be returned to clients for rendering in web browers; for example, if GLM is being used as part of a web application.</p> <p>Parameters:</p> Name Type Description Default <code>csv_lake_fname</code> <code>str</code> <p>File name of csv of outputs from GLM - <code>lake.csv</code>.</p> required <code>variables</code> <code>list</code> <p>List of variable names from <code>lake.csv</code> to select and convert to JSON format..</p> required <p>Returns:</p> Type Description <code>dict     JSON formatted results of GLM simulation.</code>"},{"location":"simulation/#glmpy.simulation.GlmPostProcessor.csv_to_json_files","title":"<code>csv_to_json_files()</code>","text":"<p>Convert csv of GLM outputs to JSON format and writes to a <code>.json</code> file.</p>"},{"location":"simulation/#glmpy.simulation.GlmPostProcessor.zip_csvs","title":"<code>zip_csvs()</code>","text":"<p>Creates a zipfile of csv GLM outputs (csv outputs only).</p> <p>Use this if you do not need a netcdf file of GLM outputs.</p> <p>Returns:</p> Type Description <code>str     Path to zipfile of GLM outputs.</code>"},{"location":"simulation/#glmpy.simulation.GlmPostProcessor.zip_json","title":"<code>zip_json()</code>","text":"<p>Creates a zipfile of csv GLM outputs converted to JSON format.</p> <p>Use this, for example, if you are using GLM within a web application and outputs from GLM simulations are being passed between clients and servers. Saving outputs of GLM simulations to JSON format is useful if you want to render results in a web browser, for example.</p> <p>Returns:</p> Type Description <code>str     Path to zipfile of GLM outputs.</code>"},{"location":"simulation/#glmpy.simulation.GlmPostProcessor.zip_outputs","title":"<code>zip_outputs()</code>","text":"<p>Creates a zipfile of GLM outputs (csv and netcdf outputs).</p> <p>Returns:</p> Type Description <code>str     Path to zipfile of GLM outputs.</code>"},{"location":"simulation/#glmpy.simulation.GlmSim","title":"<code>GlmSim</code>","text":"<p>Prepare inputs and run a GLM simulation.</p> <p>The <code>GlmSim</code> class has attributes and methods that handle running GLM simulations and processing the results.</p> <p>The class is designed to work with GLM simulations running on local instances of GLM or instances of GLM behind a FastAPI web API (i.e. when running GLM simulations as a web service). When running GLM locally input files required for a simulation (e.g. glm3.nml, met.csv) should be passed in as dict object with the format: <code>{\"&lt;filename&gt;\": \"&lt;path-to-file&gt;\"}. When running GLM behind a web API, input files can be sent to the server from a client through a HTTP request and will be processed as a FastAPI</code>UploadFile` object: https://fastapi.tiangolo.com/tutorial/request-files/#uploadfile</p> <p>Examples:</p> <p>Running GLM as a web service behind a FastAPI endpoint. <code>files</code> is a FastAPI <code>UploadFile</code> object.</p> <pre><code>&gt;&gt;&gt; import glmpy.simulation as sim\n&gt;&gt;&gt; glm_sim = sim.GlmSim(files, True, \"/inputs)\n&gt;&gt;&gt; inputs_dir = glm_sim.prepare_inputs()\n&gt;&gt;&gt; glm_sim.glm_run(inputs_dir, \"/glm/glm\")\n</code></pre> <p>Running GLM locally. <code>files</code> is a dict object with paths to where input files are stored.</p> <pre><code>&gt;&gt;&gt; import glmpy.simulation as sim\n&gt;&gt;&gt; files = {\n&gt;&gt;&gt;    \"glm3.nml\": \"/path/to/glm3.nml\",\n&gt;&gt;&gt;    \"met.csv\": \"/path/to/met.csv\"\n&gt;&gt;&gt; }\n&gt;&gt;&gt; glm_sim = sim.GlmSim(files, False, \"/inputs)\n&gt;&gt;&gt; inputs_dir = glm_sim.prepare_inputs()\n&gt;&gt;&gt; glm_sim.glm_run(inputs_dir, \"/glm/glm\")\n</code></pre>"},{"location":"simulation/#glmpy.simulation.GlmSim.__init__","title":"<code>__init__(input_files, api, inputs_dir)</code>","text":"<p>Initialise a <code>GlmSim</code> object.</p> <p>Attributes:</p> Name Type Description <code>input_files</code> <code>Union[UploadFile, dict]</code> <p>FastAPI <code>UploadFile</code> object storing input files for a GLM simulation or, if running GLM locally or outside a FastAPI environment a dict of filenames (keys) and paths to files (values).</p> <code>api</code> <code>bool</code> <p>If True, GLM is run using FastAPI engine. Otherwise, local GLM versions.</p> <code>inputs_dir</code> <code>str</code> <p>File path to directory to save input files for GLM simulation.</p>"},{"location":"simulation/#glmpy.simulation.GlmSim.glm_run","title":"<code>glm_run(inputs_dir, glm_path)</code>","text":"<p>Run a GLM simulation.</p> <p>Parameters:</p> Name Type Description Default <code>inputs_dir</code> <code>str</code> <p>File path to directory with input files required for a GLM simulation.</p> required <code>glm_path</code> <code>str</code> <p>Path to location of GLM binary.</p> required"},{"location":"simulation/#glmpy.simulation.GlmSim.prepare_inputs","title":"<code>prepare_inputs()</code>","text":"<p>Prepare input files for a GLM simulation.</p> <p>If <code>inputs_dir</code> exists, it will be deleted and a new directory created with new input files.</p> <p>Returns:</p> Type Description <code>str     File path to directory with input files required for a GLM</code> <p>simulation.</p>"},{"location":"sparkling-lake-tutorial/","title":"Tutorials","text":""},{"location":"sparkling-lake-tutorial/#sparkling-lake","title":"Sparkling Lake","text":""},{"location":"sparkling-lake-tutorial/#introduction","title":"Introduction","text":"<p>Sparkling Lake is an oligotrophic, northern temperate lake (89.7 \u00baN, 46.3 \u00baW) in Winconsin, USA. The lake has a surface area of 0.638 km2, and is about 20 m deep. This tutorial will guide users through the process of setting up a model of Sparkling Lake using the <code>glmpy</code> package. The model will be configured to  simulate the hydrological domain of Sparkling Lake for 2 years, from 1980-04-15 to 1982-04-15, with water balance and heat fluxes hypothetically calculated based on the lake configuration and input data.</p>"},{"location":"sparkling-lake-tutorial/#the-glm-nml-file","title":"The GLM <code>.nml</code> file","text":"<p>To begin, start by importing the <code>nml</code> module from <code>glmpy</code>:</p> <pre><code>from glmpy import nml\n</code></pre> <p>The <code>nml</code> module provides a set of methods and classes to work with namelist files (<code>.nml</code>), which are used to configure the model parameters of GLM. Each GLM simulation requires a namelist file containing a list of the model parameters and their values. The GLM namelist file is divided into multiple blocks that configure specific aspects of the simulation, e.g., the lake morphometry. The structure of a GLM namelist file is shown below for four of the required blocks (<code>...</code> indicates that the block contains more parameters than shown):</p> <pre><code>&amp;glm_setup\n  sim_name = 'GLMSimulation'\n  ...\n/\n&amp;morphometry\n  lake_name = 'my_lake'\n  ...\n/\n&amp;time\n  timefmt = 3\n  ...\n/\n&amp;init_profiles\n  lake_depth = 10\n  ...\n/\n</code></pre> <p>The <code>nml</code> module provides a set of classes that are used to define each of these blocks.</p>"},{"location":"sparkling-lake-tutorial/#model-setup","title":"Model setup","text":"<p>As a 1-dimensional model, GLM simulates the dynamics of a water body by dividing it into a vertically stacked series of layers. The compulsory <code>&amp;glm_setup</code> block defines the structure of these layers, e.g., the maximum number of layers, the minimum layer volume, and the minimum and maximum layer thicknesses. Let's configure the <code>&amp;glm_setup</code> block using the <code>NMLSetup</code> class:</p> <pre><code>setup = nml.NMLSetup(\nsim_name='Sparkling Lake',\nmax_layers=500,\nmin_layer_vol=0.5,\nmin_layer_thick=0.15,\nmax_layer_thick=0.5,\ndensity_model=1,\nnon_avg=True\n)\n</code></pre> <p>Alternatively, these attributes can also be passed to <code>NMLSetup</code> as a dictionary object:</p> <pre><code>setup = nml.NMLSetup()\nsetup_attrs = {\n'sim_name': 'Sparkling Lake',\n'max_layers': 500,\n'min_layer_vol': 0.5,\n'min_layer_thick': 0.15,\n'max_layer_thick': 0.5,\n'density_model': 1,\n'non_avg': True\n}\nsetup.set_attributes(setup_attrs)\n</code></pre> <p>Regardless of how you set the attributes, you can inspect the <code>.nml</code> formatted <code>setup</code> object by printing it:</p> <pre><code>print(setup)\n</code></pre> <pre><code>&amp;glm_setup\n   sim_name = 'Sparkling Lake'\n   max_layers = 500\n   min_layer_vol = 0.5\n   min_layer_thick = 0.15\n   max_layer_thick = 0.5\n   density_model = 1\n   non_avg = .true.\n/\n</code></pre>"},{"location":"sparkling-lake-tutorial/#mixing","title":"Mixing","text":"<p>Next, let's set the parameters that control the mixing processes between the simulated layers of Sparkling lake. Just as <code>NMLSetup</code> defines the <code>&amp;glm_setup</code> block, we can configure the <code>&amp;glm_mixing</code> block using the <code>NMLMixing</code> class:</p> <pre><code>mixing = nml.NMLMixing(\nsurface_mixing=1,\ncoef_mix_conv=0.2,\ncoef_wind_stir=0.402,\ncoef_mix_shear=0.2,\ncoef_mix_turb=0.51,\ncoef_mix_KH=0.3,\ndeep_mixing=2,\ncoef_mix_hyp=0.5,\ndiff=0.0\n)\n</code></pre> <p>Let's take a look at the result:</p> <pre><code>print(mixing)\n</code></pre> <pre><code>&amp;mixing\n   surface_mixing = 1\n   coef_mix_conv = 0.2\n   coef_wind_stir = 0.402\n   coef_mix_shear = 0.2\n   coef_mix_turb = 0.51\n   coef_mix_KH = 0.3\n   deep_mixing = 2\n   coef_mix_hyp = 0.5\n   diff = 0.0\n/\n</code></pre>"},{"location":"sparkling-lake-tutorial/#morphometry","title":"Morphometry","text":"<p>The <code>&amp;morphometry</code> block defines the physical measurements and structure of the lake. Comma-separated lists are used to detail the area at various elevations of the lake. These are listed from the lake bottom to the surface. Set the following attributes and inspect the result:</p> <pre><code>morphometry = nml.NMLMorphometry(\nlake_name='Sparkling',\nlatitude=46.00881,\nlongitude=-89.69953,\nbsn_len=901.0385,\nbsn_wid=901.0385,\ncrest_elev=320.0,\nbsn_vals=15,\nH=[301.712, 303.018285714286, 304.324571428571,\n305.630857142857, 306.937142857143, 308.243428571429,\n309.549714285714, 310.856, 312.162285714286,\n313.468571428571, 314.774857142857, 316.081142857143,\n317.387428571429, 318.693714285714, 320, 321],\nA=[0, 45545.8263571429, 91091.6527142857,\n136637.479071429, 182183.305428571, 227729.131785714,\n273274.958142857, 318820.7845, 364366.610857143,\n409912.437214286, 455458.263571429, 501004.089928571,\n546549.916285714, 592095.742642857, 637641.569, 687641.569]\n)\n</code></pre> <pre><code>print(morphometry)\n</code></pre> <pre><code>&amp;morphometry\n   lake_name = 'Sparkling'\n   latitude = 46.00881\n   longitude = -89.69953\n   crest_elev = 320.0\n   bsn_len = 901.0385\n   bsn_wid = 901.0385\n   bsn_vals = 15\n   H = 301.712, 303.018285714286, 304.324571428571, 305.630857142857, 306.937142857143, 308.243428571429, 309.549714285714, 310.856, 312.162285714286, 313.468571428571, 314.774857142857, 316.081142857143, 317.387428571429, 318.693714285714, 320, 321\n   A = 0, 45545.8263571429, 91091.6527142857, 136637.479071429, 182183.305428571, 227729.131785714, 273274.958142857, 318820.7845, 364366.610857143, 409912.437214286, 455458.263571429, 501004.089928571, 546549.916285714, 592095.742642857, 637641.569, 687641.569\n/\n</code></pre>"},{"location":"sparkling-lake-tutorial/#setting-the-remaining-blocks","title":"Setting the remaining blocks","text":"<p>There are up to 14 configurable blocks in the GLM namelist file - setting each will take some time! Let's speed up the process by importing a JSON file that contains the parameters for the remaining blocks. We'll use the <code>JSONToNML</code> class to extract the relevant attributes from each respective block. Download the JSON file here.</p> <p>Import <code>JSONToNML</code> from <code>glmpy</code> and pass the JSON file to the class:</p> <pre><code>from glmpy import json\njson_attributes = json.JSONToNML(\"sparkling_lake.json\")\n</code></pre> <p>Let's have a go at extracting attributes for the <code>&amp;meteorology</code> block using the <code>get_nml_attributes()</code> method. This block defines the complex interactions that occur between the lake and the atmosphere, e.g., radiation, heat fluxes, rainfall, and wind. We'll pass in the name of the block as it appears in the JSON file:</p> <pre><code>meteorology_attrs = json_attributes.get_nml_attributes(\"&amp;meteorology\")\n</code></pre> <p>Take a look at what <code>meteorology_attrs</code> contains:</p> <pre><code>print(meteorology_attrs)\n</code></pre> <pre><code>{'met_sw': True, 'lw_type': 'LW_IN', 'rain_sw': False, 'atm_stab': 0, 'catchrain': False, 'rad_mode': 1, 'albedo_mode': 1, 'cloud_mode': 4, 'fetch_mode': 0, 'subdaily': False, 'meteo_fl': 'bcs/nldas_driver.csv', 'wind_factor': 1, 'sw_factor': 1.08, 'lw_factor': 1, 'at_factor': 1, 'rh_factor': 1, 'rain_factor': 1, 'ce': 0.00132, 'ch': 0.0014, 'cd': 0.0013, 'rain_threshold': 0.01, 'runoff_coef': 0.3}\n</code></pre> <p>This is a dictionary containing all attributes for the <code>&amp;meteorology</code> block. Let's pass these to the <code>NMLMeteorology</code> class with the <code>set_attributes()</code> method:</p> <pre><code>meteorology = nml.NMLMeteorology()\nmeteorology.set_attributes(meteorology_attrs)\nprint(meteorology)\n</code></pre> <pre><code>&amp;meteorology\n   met_sw = .true.\n   meteo_fl = 'bcs/nldas_driver.csv'\n   subdaily = .false.\n   rad_mode = 1\n   albedo_mode = 1\n   sw_factor = 1.08\n   lw_type = 'LW_IN'\n   cloud_mode = 4\n   lw_factor = 1\n   atm_stab = 0\n   rh_factor = 1\n   at_factor = 1\n   ce = 0.00132\n   ch = 0.0014\n   rain_sw = .false.\n   rain_factor = 1\n   catchrain = .false.\n   rain_threshold = 0.01\n   runoff_coef = 0.3\n   cd = 0.0013\n   wind_factor = 1\n   fetch_mode = 0\n/\n</code></pre> <p>Easy! But before we go any futher, look closely at the <code>meteo_fl</code> attribute - what's <code>bcs/nldas_driver.csv</code>? This is a path to a CSV that contains boundary condition data for Sparkling Lake, e.g., daily rainfall, wind speed, and air temperature. You'll need this file to run the model. Download it here.</p> <p>Now, let's do the same for the remaining blocks:  <code>&amp;output</code>, <code>&amp;init_profiles</code>, <code>&amp;time</code>, <code>&amp;bird_model</code>, <code>&amp;light</code>, <code>&amp;sediment</code>. There won't be any more boundary conidition files to include. If you're want to find out more about the attributes for each block, check out the NML documentation.</p> <pre><code>output_attrs=json_attributes.get_nml_attributes(\"&amp;output\")\ninit_profiles_attrs=json_attributes.get_nml_attributes(\"&amp;init_profiles\")\ntime_attrs=json_attributes.get_nml_attributes(\"&amp;time\")\nlight_attrs=json_attributes.get_nml_attributes(\"&amp;light\")\nbird_model_attrs=json_attributes.get_nml_attributes(\"&amp;bird_model\")\nsediment_attrs=json_attributes.get_nml_attributes(\"&amp;sediment\")\nwq_setup_attrs=json_attributes.get_nml_attributes(\"&amp;wq_setup\")\n</code></pre> <p>Now initialise the respective classes:</p> <pre><code>output = nml.NMLOutput()\ninit_profiles = nml.NMLInitProfiles()\ntime = nml.NMLTime()\nlight = nml.NMLLight()\nbird_model = nml.NMLBirdModel()\nsediment = nml.NMLSediment()\nwq_setup = nml.NMLWQSetup()\n</code></pre> <p>And set the attributes:</p> <pre><code>output.set_attributes(output_attrs)\ninit_profiles.set_attributes(init_profiles_attrs)\ntime.set_attributes(time_attrs)\nlight.set_attributes(light_attrs)\nbird_model.set_attributes(bird_model_attrs)\nsediment.set_attributes(sediment_attrs)\nwq_setup.set_attributes(wq_setup_attrs)\n</code></pre>"},{"location":"sparkling-lake-tutorial/#writing-the-namelist-file","title":"Writing the namelist file","text":"<p>Now that we have the attributes set for each block, the <code>.nml</code> file can be compiled and written to disk. First, create an instance of the <code>NML</code> class and pass in the configured blocks. Using the <code>write_nml()</code> method, the <code>.nml</code> can be saved to your directory.</p> <pre><code>nml = nml.NML(\nsetup=setup,\nmixing=mixing,\nmorphometry=morphometry,\ntime=time,\noutput=output,\ninit_profiles=init_profiles,\nmeteorology=meteorology,\nbird_model=bird_model,\nlight=light,\nsediment=sediment\n)\nnml.write_nml(nml_file_path='glm3.nml')\n</code></pre>"},{"location":"sparkling-lake-tutorial/#running-the-model","title":"Running the model","text":"<p>Model configuration is now complete! To run glm, first import the <code>simulation</code> module:</p> <pre><code>import glmpy.simulation as sim\n</code></pre> <p>We now need to specify the location of any files we'll be using in the simulation. For Sparkling lake, that's just your newly created <code>glm3.nml</code> and the meterological boundary condition file <code>nldas_driver.csv</code>. These will be defined in a dictionary where the key is the file name and the value is the filepath:</p> <pre><code>files = {\n\"glm3.nml\": \"/path/to/glm3.nml\",\n\"nldas_driver.csv\": \"/path/to/nldas_driver.csv\"\n}\n</code></pre> <p>Pass this dictionary to a new instance of the <code>GlmSim</code> class. <code>GlmSim</code> will prepare a new directory called <code>inputs</code> that structures our files in a way that GLM expects. Set <code>api</code> to <code>False</code> to run the simulation locally:</p> <pre><code>glm_sim = sim.GlmSim(\ninput_files=files,\napi=False,\ninputs_dir=\"inputs\"\n)\n</code></pre> <p>Create the <code>inputs</code> directory by calling the <code>.prepare_inputs()</code> method:</p> <pre><code>inputs_dir = glm_sim.prepare_inputs()\n</code></pre> <p>You should now have a new directory that looks like this:</p> <pre><code>\u251c\u2500\u2500 bcs\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 nldas_driver.csv\n\u251c\u2500\u2500 glm3.nml\n</code></pre> <p>Finally, run the simulation with the <code>.glm_run()</code> method. Pass in the <code>inputs_dir</code> object and a string containing the path to the GLM binary:</p> <pre><code>glm_sim.glm_run(inputs_dir=inputs_dir, glm_path=\"/path/to/glm/binary\")\n</code></pre> <p>GLM will run the simulation. You should see a new directory called <code>outputs</code> that contains the model results.</p>"}]}